<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kyle Halladay - GBA By Example - Drawing and Moving Sprites</title>
  <meta name="author" content="Kyle Halladay" />
  <meta name="description" content="I build shaders, renderers, games, and other stuff that's fun to stare at." />
  <link rel="canonical" href="http://kylehalladay.com/blog/tutorial/2017/04/04/GBA-By-Example-2.html" />
  <meta name="keywords" content="life,code,software,development,games,graphics,shaders,indie" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Kyle Halladay" href="http://kylehalladay.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.jpg" id="logo" alt="Blog logo"/>
  </a>
  <h2>I'm <a href="/">Kyle Halladay</a>.</h2>
  <div id="bio">
    <p>I build shaders, graphics tech, and art pipelines for games. </p>
    <p>Check out <a href="/archive.html">Some other stuff I've written</a></p>
  </div>
  <div id="social">
    Want to say hi?
<div id="stalker">
  
  <a title="khalladay on Github" href="https://github.com/khalladay">
    <i class="fa fa-github-square"></i>
  </a>
  

  

  

  

  

  
  <a title="khalladay on Twitter" href="https://twitter.com/khalladay">
    <i class="fa fa-twitter-square"></i>
  </a>
  

  

  

  
  <a title="Kyle Halladay on LinkedIn" href="https://www.linkedin.com/in/kylehalladay">
    <i class="fa fa-linkedin-square"></i>
  </a>
  

  

  
  <a title="Kyle Halladay via Email" href="mailto:k.mj.halladay@gmail.com">
    <i class="fa fa-envelope-square"></i>
  </a>
  

  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="fa fa-rss-square"></i>
  </a>
</div>

  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <topbar><div align="center"><h2><a href="/index.html" style="color:#000">KyleHalladay.com</a></h2></div>
      <div align="center" style="font-size:18px"><a href="/archive.html">Archive</a></div>
      <hr style="border-color:#000; margin:1em -0.25em;"></topbar>

      <p class="meta">
 
</p>

<h1 class="title">GBA By Example - Drawing and Moving Sprites</h1>

<div id="post">
  <p><a href="http://kylehalladay.com/blog/tutorial/2017/03/28/GBA-By-Example-1.html">Last week</a>, we were working in video mode 3, which is one of the “bitmap” video modes. These modes are named so because they use the GBA’s 96K of video memory (VRAM) to store a representation of the screen as an array of colour values. If you want to draw to pixel (0,0), you simply set the first element in the screen buffer array to the colour you want, and when the hardware draws, it reads the value at that location, and draws it to the screen.</p>

<p>While some games did use the bitmap modes to do some pretty amazing stuff (like <a href="http://www.ign.com/games/james-bond-007-nightfire/gba-497891">James Bond 007: NightFire</a> and <a href="http://www.ign.com/games/stuntman/gba-550094">Stuntman</a>), they were the exception, not the rule. Most GBA games that were released were purely 2D, and used what are called Tiled Video Modes, which provide hardware level optimizations for 2D drawing tasks.</p>

<p>So today I’m going to walk through the bare minimum needed to use one of these tiled video modes to draw (and move) a sprite across the screen, which might end up looking like this:</p>

<div align="center">
<img src="/images/post_images/2017-04-04/preview.gif" style="width:240px;height:160px" />
<font size="2">(Forgive the Programmer Art)</font><br /><br />
</div>

<p>Let’s get started!</p>

<h2 id="introducing-tiled-video-modes">Introducing Tiled Video Modes</h2>

<p>Tiled video modes are different from the bitmap modes because they don’t store large colour arrays in VRAM. Instead, VRAM is used to store collections of tiles (8x8 collections of colour values), and data about how to display these tiles. There are 3 different tiled video modes (mode 0 - mode 2), but I don’t really know enough right now to worry about the differences between them right now to make an informed choice about which one to use. Until that changes, I’m going to work in Mode 0 and kinda plug my ears and try not to think too hard about it:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define REG_DISPLAYCONTROL     *((volatile uint16*)(0x04000000))
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">REG_DISPLAYCONTROL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//mode 0, no background enabled
</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Since what we store in VRAM has changed since last week, it makes sense that there are a few new data structures that we’re going to have to understand in order to get anything useful into memory (and do anything interesting).</p>

<p>As mentioned, a <em>Tile</em> is an 8x8 collection of colour values (stored linearly, one row after the other), but these colour values are not the colours the sprite will actually use on screen. Instead, these values are used to look up the colour in a <em>Palette</em>, which is another data structure we’re going to have to wrangle today.</p>

<p>A <em>Palette</em> is a block of memory that contains colour values, plain and simple. An application gets 2 of these blocks of memory, one for backgrounds, and one for sprites. Each section is large enough to contain 256 colour values.</p>

<p>Tiles can take the form of 8bpp (bits per pixel), or 4bpp. 8bpp mode is pretty straightforward - we have 8 bits to play with, which means each value in our tile can be one of 256 possible values, which is exactly how many values we can store in a palette. In 4bpp mode, we get up to 16 possible values for each pixel, which means that we can only use a section of our palette memory for each sprite.</p>

<p>Because it sounds easier, and I promised that this article was the bare minimum we needed to draw a sprite, we’re going to use 8bpp today.</p>

<p>Finally, a Sprite is a rectangular collection of tiles, so when we format images to be used on the GBA, we need to break them up into 8x8 tiles, and a palette of colours that those tiles use, and then provide some data about which locations in Tile and Palette memory our sprite will use. It’s important to note that the GBA calls Sprites “Objects” (not the OOP kind). You can split hairs about this, but a GBA Object is a collection of tiles, arranged rectangularly, that move around the screen. Sounds like a Sprite to me.</p>

<p>I’m sure there are reasons why this isn’t true 100% of the time, but those reasons aren’t really important today.</p>

<p>So to wrap this section up:</p>

<ul>
  <li>A Palette is an array of 256 colour values</li>
  <li>A Tile’s colour values are actually indices into Palette memory</li>
  <li>A Sprite is a (theoretical) rectangular collection of tiles.</li>
  <li>The hardware equivalent of a Sprite is called an Object</li>
</ul>

<p><br />
Hopefully that’s all relatively clear! Let’s start putting all of this together</p>

<h2 id="working-with-sprite-data">Working With Sprite Data</h2>

<p>The first thing we need to do is to actually have some tile and colour data to use in our program.</p>

<p>For this section, I’m going to simply provide the data that we’re going to use. At the end of this post, I’ll link you to tools that you can use to make your own. To start with, let’s consider a really simple sprite, which consists of only a single tile, and 3 palette colours.</p>

<div align="center">
<img src="/images/post_images/2017-04-04/testsprite.png" />
<font size="2">(Grid lines added to help differentiate pixels, not included in sprite)</font><br /><br />
</div>

<p>Here’s what that sprite might look like in our program:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">testTiles</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span><span class="o">=</span>
<span class="p">{</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
    <span class="mh">0x00000001</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
    <span class="mh">0x02020102</span><span class="p">,</span><span class="mh">0x02020202</span><span class="p">,</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">testPal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span><span class="o">=</span>
<span class="p">{</span>
    <span class="mh">0x03E0001F</span><span class="p">,</span><span class="mh">0x00007C00</span><span class="p">,</span>
<span class="p">};</span></code></pre></div>

<p>You can see that most of this is what we would expect, the testTiles data traverses each row in order from top to bottom, with each tile index getting 8 bits (2 hex numbers) of data allocated, so each 32 bit value represents 4 pixels. The lowest bits represent the leftmost pixels, which makes sense logically, even if it makes things harder to read when you’re looking at hex values.</p>

<p>The palette data is also as we would expect, containing the three colours used in our sprite, represented as 15 bit colours, with 2 colours per 32 bit value.</p>

<p>The <strong>attribute</strong>((aligned(4))) is a gcc macro to force your data to be aligned on 4 byte boundaries. I took it straight from the <a href="http://www.coranac.com/tonc/text/regobj.htm">Tonc tutorial</a>, which says:</p>

<blockquote>
  <p>As of devkitARM r19, there are new rules on struct alignments, which means that structs may not always be word aligned, and in the case of OBJ_ATTR structs (and others), means that [some] struct-copies …  will not only be slow, they may actually break. For that reason, I will force word-alignment on many of my structs…</p>
</blockquote>

<p>Since I don’t know enough to argue with that right now, I’m taking it on faith that this is still a good idea.</p>

<p>Now that we know what our sprite data is going to look like, let’s use a slightly larger data set. This is mostly to make sure that what we do later is correctly ordering the tiles in our sprite. If we used the example data above, we wouldn’t be able to verify this because we only had 1 tile. Here’s the sprite and data that I’m going to be using for the rest of the article:</p>

<div align="center">
<img src="/images/post_images/2017-04-04/realsprite.png" /><br />
</div>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spriteTiles</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span><span class="o">=</span>
<span class="p">{</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x01000000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x01010000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x01010100</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x01010101</span><span class="p">,</span>
    <span class="mh">0x01000000</span><span class="p">,</span><span class="mh">0x01010101</span><span class="p">,</span><span class="mh">0x01010000</span><span class="p">,</span><span class="mh">0x01010101</span><span class="p">,</span><span class="mh">0x01010100</span><span class="p">,</span><span class="mh">0x01010101</span><span class="p">,</span><span class="mh">0x01010101</span><span class="p">,</span><span class="mh">0x01010101</span><span class="p">,</span>
    <span class="mh">0x00000003</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000303</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00030303</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x03030303</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
    <span class="mh">0x03030303</span><span class="p">,</span><span class="mh">0x00000003</span><span class="p">,</span><span class="mh">0x03030303</span><span class="p">,</span><span class="mh">0x00000303</span><span class="p">,</span><span class="mh">0x03030303</span><span class="p">,</span><span class="mh">0x00030303</span><span class="p">,</span><span class="mh">0x03030303</span><span class="p">,</span><span class="mh">0x03030303</span><span class="p">,</span>
    <span class="mh">0x04040404</span><span class="p">,</span><span class="mh">0x04040404</span><span class="p">,</span><span class="mh">0x04040400</span><span class="p">,</span><span class="mh">0x04040404</span><span class="p">,</span><span class="mh">0x04040000</span><span class="p">,</span><span class="mh">0x04040404</span><span class="p">,</span><span class="mh">0x04000000</span><span class="p">,</span><span class="mh">0x04040404</span><span class="p">,</span>
    <span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x04040404</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x04040400</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x04040000</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x04000000</span><span class="p">,</span>
    <span class="mh">0x02020202</span><span class="p">,</span><span class="mh">0x02020202</span><span class="p">,</span><span class="mh">0x02020202</span><span class="p">,</span><span class="mh">0x00020202</span><span class="p">,</span><span class="mh">0x02020202</span><span class="p">,</span><span class="mh">0x00000202</span><span class="p">,</span><span class="mh">0x02020202</span><span class="p">,</span><span class="mh">0x00000002</span><span class="p">,</span>
    <span class="mh">0x02020202</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00020202</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000202</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span><span class="mh">0x00000002</span><span class="p">,</span><span class="mh">0x00000000</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spritePal</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span><span class="o">=</span>
<span class="p">{</span>
    <span class="mh">0x001E0000</span><span class="p">,</span><span class="mh">0x03E07FFF</span><span class="p">,</span><span class="mh">0x00007C1F</span><span class="p">,</span>
<span class="p">};</span></code></pre></div>

<p>If you take a look at this larger sprite data, you’ll notice that it’s stored as a sequential array of 8x8 tiles, that is, the 3rd 32 bit value isn’t the first four pixels of the top right tile, it’s the first four pixels of the second row of the top left tile. This is to make things easier to get into VRAM, since we have to upload tiles, not whole images. Mercifully, there’s a command line tool that I’ll link later that will convert images to this format for us, so we don’t have to try to author images like this.</p>

<p>For readability sake, I’m going to put the above block of code into it’ own .c file, that I’m going to call sprite.c. I’m also going to create sprite.h, which looks like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#ifndef SPRITE_H
#define SPRITE_H
</span>
<span class="cp">#define spriteTilesLen 256 //size in bytes
</span><span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spriteTiles</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

<span class="cp">#define spritePalLen 12
</span><span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spritePal</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="cp">#endif</span></code></pre></div>

<p>I’m using 32 bit values to store everything, because when I tried to use 16 bit values, I ended up needing to pad my sizes in the header to the nearest multiple of 8 (so spritePalLen had to be 16), or else some data wouldn’t transfer. I’m not entirely sure why that is (or why making things ints fixed that), but I decided I’d rather not have to remember to do that, and chose to stick with 32 bit values even though they make the data slightly harder to read.</p>

<h2 id="getting-all-this-into-vram">Getting All This Into VRAM</h2>

<p>We have sprite data and palette data ready to go, but as we discussed earlier, we’re going to need to get this data into the proper parts of memory. Specifically, we’ll need to add the palette values to our larger 256 colour palette memory, upload tile data to tile memory, and then create a sprite that references those tiles.</p>

<p>Let’s start with the palette memory:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include "sprite.h"
</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>      <span class="n">uint8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>     <span class="n">uint16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">uint32</span><span class="p">;</span>

<span class="cp">#define MEM_PALETTE   ((uint16*)(0x05000200))
</span><span class="kt">void</span> <span class="nf">UploadPaletteMem</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_PALETTE</span><span class="p">,</span> <span class="n">spritePal</span><span class="p">,</span> <span class="n">spritePalLen</span><span class="p">);</span>

<span class="p">}</span></code></pre></div>

<p>This is pretty straightforward, the only thing to note is that in other articles, what I’m calling MEM_PALETTE here is usually called MEM_OBJ_PAL, or something similar. This is because palette memory on the GBA is divided into two sections, but we’re only using one of them today, so for simplicity’s sake, I’m just calling it MEM_PALETTE and pretending that’s all there is to it.</p>

<p>Next we need to upload our tile memory, this is a bit less straightforward:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">uint32</span> <span class="n">Tile</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">Tile</span> <span class="n">TileBlock</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="cp">#define MEM_VRAM        ((volatile uint32*)0x06000000)
#define MEM_TILE        ( (TileBlock*)MEM_VRAM )
</span>
<span class="kt">void</span> <span class="nf">UploadTileMem</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">spriteTiles</span><span class="p">,</span> <span class="n">spriteTilesLen</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>To understand what’s going on here, we need to know a bit more about how tiles are stored in VRAM. In tiled video modes, VRAM is used to store tile data, and that data is arranged in 16kb blocks, called “tile blocks” or (more confusingly) “charblocks.” Since the GBA has 96kb of VRAM, this gives us 6 tile blocks total.</p>

<p>The first four of these tile blocks are reserved for backgrounds (which we aren’t delving into today), and the remainder are for tiles. This means that when we want to put a tile into memory, the first possible memory slot for us is at  MEM_VRAM + 64k bytes (or really, + 65536 bytes because of data alignment). This gives us a memory address of 0x6010000, but it’s much easier to get at individual tile addresses using the structs / array notation you see here.</p>

<p>I’m putting my sprite into [4][1] instead of [4][0] because writing into [4][0] ended up putting some weird artifacts on the top left corner of my screen. I’m not sure why that is yet, and I haven’t found another example of using 8bpp sprites online to see what they’re doing, so I’m going to leave it for now (if you know what’s going on, shoot me a message <a href="https://twitter.com/khalladay">on Twitter</a>).</p>

<p>The last thing we need to get into memory is a description of our sprite (since we need to know how to combine all these tiles we just put into VRAM). To do that, we’re going to define an Object.</p>

<h2 id="gba-objects-arent-objects">GBA Objects Aren’t “Objects”</h2>

<p>As mentioned earlier, a GBA Object is NOT an OOP style Object. Instead, they’re  simply a collections of tiles which can be transformed / drawn without needing to clear where they were. If you remember from <a href="http://kylehalladay.com/blog/tutorial/2017/03/28/GBA-By-Example-1.html">last week</a>, we had to do all our own clearing. Objects relieve us of that duty.</p>

<p>Unfortunately, creating an Object is a bit of an arcane exercise, so bear with me here. The first thing we need to do is to define the Object data structure, and where object memory lives:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">ObjectAttributes</span> <span class="p">{</span>
    <span class="n">uint16</span> <span class="n">attr0</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">attr1</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">attr2</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span> <span class="n">ObjectAttributes</span><span class="p">;</span>

<span class="cp">#define MEM_OAM  ((volatile ObjectAttributes *)0x07000000)</span></code></pre></div>

<p>As you may have guessed from above, you don’t technically store objects in memory (although you’re free to call your struct whatever you want), instead we store what’s referred to as “Object Attributes.” These structs are stored in “Object Attribute Memory”, or OAM.</p>

<p>There’s a lot of information packed into the three uint16 variables in the ObjectAttributes struct, and it’s easy to get lost. In the interest of being the “bare minimum” you need to move a sprite around the screen, I’m only going to talk about the bits that we’re going to use today. If you want a more granular look at things, <a href="http://www.coranac.com/tonc/text/regobj.htm">Tonc</a> does an excellent job at explaining what every bit does.</p>

<p>It’s easiest to describe how these variables work in a table, so here’s attr0</p>

<div align="center">
<table style="border:1px solid black; width=600px; padding:2px;">
<colgroup>
<col width="200px" />
<col width="400px" />
</colgroup>
<thead style="border:1px solid black; background-color:#FF8854;">
<tr class="header">
<th>Attr 0</th>
<th> 0x FEDC BA98 7654 3210</th>
</tr>
</thead>
<tbody>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td>FE</td>
<td style="border:1px solid black;">Shape of Sprite: 00 = Square, 01 = Tall, 10 = Wide</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">D</td>
<td>Colour Mode: 0 = 4bpp, 1 = 8bpp</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">C</td>
<td>Not used today</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">AB</td>
<td>Not used today</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">89</td>
<td>Not used today</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">7654 3210</td>
<td>Y Coordinate</td>
</tr>
</tbody>
</table>
</div>
<p><br /></p>

<p>Our sprite is an 8bpp, square sprite. Using this table, if we wanted to define a sprite like that, and place it at a Y coordinate of 50, we could do so like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">volatile</span> <span class="n">ObjectAttributes</span> <span class="o">*</span><span class="n">spriteAttribs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MEM_OAM</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr0</span> <span class="o">=</span> <span class="mh">0x2032</span><span class="p">;</span></code></pre></div>

<p>Here’s what we need in Attr1:</p>

<div align="center">
<table style="border:1px solid black; width=600px;">
<colgroup>
<col width="200px" />
<col width="400px" />
</colgroup>
<thead style="border:1px solid black; background-color:#FF8854">
<tr class="header">
<th>Attr 1</th>
<th> 0x FEDC BA98 7654 3210</th>
</tr>
</thead>
<tbody>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td>FE</td>
<td style="border:1px solid black;">Sprite Size (discussed below)</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">DCBA98</td>
<td>Not Used Today</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">7654 3210</td>
<td>X coordinate
</td>
</tr>
</tbody>
</table>
</div>
<p><br /></p>

<p>Sprite size is weird on the GBA. A sprite can be a maximum of 64x64, but doesn’t necessarily have to be square, meaning that what size your sprite is depends both on the value in FE or Attribute 1, and on the shape you defined in Attribute 0. They work together like this:</p>

<div align="center">
<table style="border:1px solid black; width=480px;">
<colgroup>
<col width="80px" />
<col width="100px" />
<col width="100px" />
<col width="100px" />
<col width="100px" />

</colgroup>
<tbody>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td></td>
<td style="border:1px solid black;">Size 00 </td>
<td style="border:1px solid black;">Size 01 </td>
<td style="border:1px solid black;">Size 10 </td>
<td style="border:1px solid black;">Size 11 </td>
</tr>
<tr style="border:1px solid black;">
<td style="background-color:#DDDDDD;">Shape 00</td>
<td style="border:1px solid black;">8x8 </td>
<td style="border:1px solid black;">16x16 </td>
<td style="border:1px solid black;">32x23 </td>
<td style="border:1px solid black;">64x64 </td>
</tr>
<tr style="border:1px solid black;">
<td style="background-color:#DDDDDD;">Shape 01</td>
<td style="border:1px solid black;">16x8 </td>
<td style="border:1px solid black;">32x8 </td>
<td style="border:1px solid black;">32x16 </td>
<td style="border:1px solid black;">64x32 </td>
</tr>
<tr style="border:1px solid black;">
<td style="background-color:#DDDDDD;">Shape 10</td>
<td style="border:1px solid black;">8x16 </td>
<td style="border:1px solid black;">8x32 </td>
<td style="border:1px solid black;">16x32 </td>
<td style="border:1px solid black;">32x64 </td>
</tr>
</tbody>
</table>
</div>
<p><br /></p>

<p>It certainly has some logical consistency to it, but I still find it really cumbersome to figure out what I need. In any case, given that we defined a square sprite in attribute 0, if we wanted to define a 16x16 sprite (and we do), at an x coordinate of 100, it would look like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">volatile</span> <span class="n">ObjectAttributes</span> <span class="o">*</span><span class="n">spriteAttribs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MEM_OAM</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr0</span> <span class="o">=</span> <span class="mh">0x2032</span><span class="p">;</span> <span class="c1">// 8bpp tiles, SQUARE shape
</span><span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr1</span> <span class="o">=</span> <span class="mh">0x4064</span><span class="p">;</span></code></pre></div>

<p>The last attribute we need to define is maybe the most important, since it tells the hardware where to look for the tiles in VRAM:</p>

<div align="center">
<table style="border:1px solid black; width=600px;">
<colgroup>
<col width="200px" />
<col width="400px" />
</colgroup>
<thead style="border:1px solid black; background-color:#FF8854">
<tr class="header">
<th>Attr 2</th>
<th> 0x FEDC BA98 7654 3210</th>
</tr>
</thead>
<tbody>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td>FEDC</td>
<td style="border:1px solid black;">Not Used Today</td>
</tr>
<tr style="border:1px solid black;">
<td>BA</td>
<td style="border:1px solid black;">Not Used Today</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td>98 7654 3210</td>
<td style="border:1px solid black;">First Tile Index</td>
</tr>
</tbody>
</table>
</div>
<p><br /></p>

<p>It’s worth noting that some of these tables are different when you’re working in 4bpp mode. Eventually I’ll end up using all the options available for sprite drawing, but today I just want to move a thing across my screen.</p>

<p>Combining everything we just talked about: defining our 16x16, 8bpp sprite, at location 100,50, and starting with the tile at index [4][1] looks like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">volatile</span> <span class="n">ObjectAttributes</span> <span class="o">*</span><span class="n">spriteAttribs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MEM_OAM</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr0</span> <span class="o">=</span> <span class="mh">0x2032</span><span class="p">;</span> <span class="c1">// 8bpp tiles, SQUARE shape
</span><span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr1</span> <span class="o">=</span> <span class="mh">0x4064</span><span class="p">;</span> <span class="c1">// 16x16 size when using the SQUARE shape
</span><span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>      <span class="o">//</span> <span class="n">Start</span> <span class="n">at</span> <span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></code></pre></div>

<p>You’ll notice that the index we pass to attr2 isn’t 1, which is what you’d expect to see passed there since we’re at element 1 of the array. However, the index stored in attr2 assumes that you’re using 4bpp sprites. If you’re using 8bpp like us, you need to go up by 2 indices every time you want to access the next tile.</p>

<p>With that set up, we actually have (almost) everything we need to draw our sprite, we just need to set a few more flags on our DisplayControl variable:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define REG_DISPLAYCONTROL     *((volatile uint16*)(0x04000000))
</span>
<span class="cp">#define VIDEOMODE_0    0x0000
#define ENABLE_OBJECTS 0x1000
#define MAPPINGMODE_1D 0x0040
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">REG_DISPLAYCONTROL</span> <span class="o">=</span>  <span class="n">VIDEOMODE_0</span> <span class="o">|</span> <span class="n">ENABLE_OBJECTS</span> <span class="o">|</span> <span class="n">MAPPINGMODE_1D</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre></div>

<p>As the names suggest, these flags tell the hardware to enable support for objects, and to expect tile memory to be stored as a 1D array. I’ve already covered all the info needed to understand what these mean, so hopefully they make sense now. If you’re confused about the 1D array flag, know that the only other option for tile mapping is in a 2D array, but in the interest of brevity (and imo, coding sanity), I’ve omitted that from this article. As usual, <a href="http://www.coranac.com/tonc/text/regobj.htm">Tonc</a> covers it very well if you’re interested in knowing more.</p>

<h2 id="putting-it-all-together">Putting It All Together</h2>

<p>All that’s left is to put together what we already have. Aside from the sprite include files I added earlier, all the code we need to move a sprite across the screen can easily fit below:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include "sprite.h"
#include &lt;string.h&gt;
</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>      <span class="n">uint8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>     <span class="n">uint16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">uint32</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">uint32</span> <span class="n">Tile</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">Tile</span>   <span class="n">TileBlock</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="cp">#define VIDEOMODE_0    0x0000
#define ENABLE_OBJECTS 0x1000
#define MAPPINGMODE_1D 0x0040
</span>
<span class="cp">#define REG_VCOUNT              (*(volatile uint16*) 0x04000006)
#define REG_DISPLAYCONTROL      (*(volatile uint16*) 0x04000000)
</span>
<span class="cp">#define MEM_VRAM      ((volatile uint16*)0x6000000)
#define MEM_TILE      ((TileBlock*)0x6000000 )
#define MEM_PALETTE   ((uint16*)(0x05000200))
#define SCREEN_W      240
#define SCREEN_H      160
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ObjectAttributes</span> <span class="p">{</span>
    <span class="n">uint16</span> <span class="n">attr0</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">attr1</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">attr2</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span> <span class="n">ObjectAttributes</span><span class="p">;</span>

<span class="cp">#define MEM_OAM       ((volatile ObjectAttributes *)0x07000000)
</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">REG_VCOUNT</span> <span class="o">&gt;=</span> <span class="mi">160</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">REG_VCOUNT</span> <span class="o">&lt;</span> <span class="mi">160</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_PALETTE</span><span class="p">,</span> <span class="n">spritePal</span><span class="p">,</span>  <span class="n">spritePalLen</span> <span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">spriteTiles</span><span class="p">,</span> <span class="n">spriteTilesLen</span><span class="p">);</span>

    <span class="k">volatile</span> <span class="n">ObjectAttributes</span> <span class="o">*</span><span class="n">spriteAttribs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MEM_OAM</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr0</span> <span class="o">=</span> <span class="mh">0x2032</span><span class="p">;</span> <span class="c1">// 8bpp tiles, SQUARE shape, at y coord 50
</span>    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr1</span> <span class="o">=</span> <span class="mh">0x4064</span><span class="p">;</span> <span class="c1">// 16x16 size when using the SQUARE shape
</span>    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>      <span class="c1">// Start at the first tile in tile
</span>
    <span class="n">REG_DISPLAYCONTROL</span> <span class="o">=</span>  <span class="n">VIDEOMODE_0</span> <span class="o">|</span> <span class="n">ENABLE_OBJECTS</span> <span class="o">|</span> <span class="n">MAPPINGMODE_1D</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vsync</span><span class="p">();</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">SCREEN_W</span><span class="p">);</span>
        <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr1</span> <span class="o">=</span> <span class="mh">0x4000</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x1FF</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Voila! You are now in posession of your very own moving sprite. Notice that unlike last week, we don’t have to do any work to clear the screen (thanks objects!), and all it takes to move the sprite is to update the appropriate attribute.</p>

<p>Finally, I promised to link you to the tools that I used to generate the sprites, both of which were written by the author of the <a href="http://www.coranac.com/projects/tonc/">Tonc tutorial</a>. For bitmap editing (and bitmap palette editing), I used <a href="http://www.coranac.com/projects/usenti/">Usenti</a>, and for exporting that bitmap to the .c code we looked at, I used <a href="http://www.coranac.com/projects/grit/">Grit</a>. Both tools are very straightforward, but definitely don’t overlook Grit’s GUI client (helpfully called “WinGrit”), it makes life much easier.  </p>

<p>That’s it for today! Hope you had as much fun as I did! As always, if you want to say hi, I’m most accessible <a href="https://twitter.com/khalladay">on Twitter</a>, Have a good one!</p>

</div>

<div id="related">
  <h3>More Posts</h3>
  <ul class="posts">
    
    <li>
      <span>16 May 2014 &raquo;</span> <a href="/blog/tutorial/bestof/2014/05/16/Coloured-Shadows-In-Unity.html">Colouring Shadows in Unity</a>
    </li>
    
    <li>
      <span>12 Jan 2014 &raquo;</span> <a href="/blog/tutorial/bestof/2014/01/12/Runtime-Shader-Compilation-Unity.html">Creating GLSL Shaders at Runtime in Unity3D</a>
    </li>
    
    <li>
      <span>10 Nov 2013 &raquo;</span> <a href="/blog/tutorial/bestof/2013/11/10/Libpd-and-Unity.html">Combining Pure Data and Unity</a>
    </li>
    
  </ul>
</div>


      <div class="footer">
        <div class="disclaimer">
  
  <p>
    The postings on this site are my own and don't necessarily represent my 
    employer’s positions, strategies or opinions.
  </p>
  

  <p>
    © Kyle Halladay, 2014 &mdash; built with <a href="http://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/swanson/lagom">Lagom theme</a>
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40292745-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
