<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kyle Halladay - Screen Space Distortion and a Sci-fi Shield Effect</title>
  <meta name="author" content="Kyle Halladay" />
  <meta name="description" content="I build shaders, renderers, games, and other stuff that's fun to stare at." />
  <link rel="canonical" href="http://kylehalladay.com/blog/tutorial/2016/01/15/Screen-Space-Distortion.html" />
  <meta name="keywords" content="life,code,software,development,games,graphics,shaders,indie" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Kyle Halladay" href="http://kylehalladay.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.jpg" id="logo" alt="Blog logo"/>
  </a>
  <h2>I'm <a href="/">Kyle Halladay</a>.</h2>
  <div id="bio">
    <p>I build shaders, graphics tech, and art pipelines for games. </p>
    <p>I also dabble in GBA dev, you can find my tutorials <a href="/gba.html">here.</a>
    <p>Check out <a href="/archive.html">some other stuff I've written</a></p>
  </div>
  <div id="social">
    Want to say hi?
<div id="stalker">
  
  <a title="khalladay on Github" href="https://github.com/khalladay">
    <i class="fa fa-github-square"></i>
  </a>
  

  

  

  

  

  
  <a title="khalladay on Twitter" href="https://twitter.com/khalladay">
    <i class="fa fa-twitter-square"></i>
  </a>
  

  

  

  
  <a title="Kyle Halladay on LinkedIn" href="https://www.linkedin.com/in/kylehalladay">
    <i class="fa fa-linkedin-square"></i>
  </a>
  

  

  
  <a title="Kyle Halladay via Email" href="mailto:k.mj.halladay@gmail.com">
    <i class="fa fa-envelope-square"></i>
  </a>
  

  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="fa fa-rss-square"></i>
  </a>
</div>

  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <topbar><div align="center"><h2><a href="/index.html" style="color:#000">KyleHalladay.com</a></h2></div>
      <div align="center" style="font-size:18px"><a href="/archive.html">Archive</a></div>
      <hr style="border-color:#000; margin:1em -0.25em;"></topbar>

      <p class="meta">

</p>

<h1 class="title">Screen Space Distortion and a Sci-fi Shield Effect</h1>

<div id="post">
  <p>Sometimes inspiration comes from the weirdest places. I was idly browsing reddit after work awhile ago and stumbled onto this post by user <a href="http://reddit.com/u/Guillaume_Langis">Guillaume_Langis</a>. It was a gif of a shield effect that they had created for their game <a href="http://projectwarfleet.blogspot.ca/">Warfleet</a>. The comments section on that site was filled (predictably) with users asking how they effect was done, and Guillame ended up actually posting the c# and shader source online for people to play with, which is awesome (thanks!)</p>

<p>The effect already looks great, but when I think of a sci-fi shield I think of distortion, and wobbling “force field” style effects, which is what I’m going to add to the shield effect, talk about in this article and use to turn the shield effect into this:</p>

<div align="center">
<img src="/images/post_images/2016-1-15/spaceshipteaser.gif" />
<br />
<br />
</div>

<h2>Some Initial Housekeeping</h2>

<p>The space ship in these screen shots is available free on the asset store, and the texture I threw on the shield was just one I got by googling for “plasma texture.” I also took the liberty of optimizing the original effect which was posted to reddit. You can find the original code <a href="https://www.dropbox.com/s/y083i4mz0f4n81o/Shield%20Effect.zip?dl=0">here</a>.</p>

<p>All the scripts and shaders used in this post will be available at the end of the article, but to start with, I’ve uploaded a unity project with a scene set up with this effect ready to go so that it’s easy to follow along <a href="https://drive.google.com/folderview?id=0B85AH3b17yxpVzZkbkM1bjdDNU0&amp;usp=sharing">here</a>. This article is about how to build a distortion effect, not about how to create to shield effect so it won’t be explained, but it will be a lot easier to follow this post if you have a project set up with it. I haven’t included the space ship or space textures from the screenshots because I didn’t make those, but you should be able to get them yourself pretty easily. As we go through this post, my screenshots will alternate between what the sample scene should look like and what it looks like with real assets.</p>

<p>Ok, now that that’s out of the way, time to get cracking.</p>

<h2>The Basics of Screen Space Distortion</h2>

<p>Let’s start by talking about what exactly a Screen Space Distortion effect is. You’ve definitely seen the effect before, it’s used to render everything from refraction to heat haze to trippy drug sequences in games, and it’s actually really simple.</p>

<p>At it’s core, all the effect requires is that you render your main camera (the one which will show the distortion) to a texture instead of rendering it directly to the framebuffer, then blit it (draw it) to the frame buffer from that texture using a shader which offsets the uvs used to sample your main camera texture.</p>

<p>A really simple example might look something like this:</p>

<div align="center">
<img src="/images/post_images/2016-1-15/warp.png" />
<br />
<br />
</div>

<p>Of course, there isn’t a one size fits all way to modify the UV coordinates, which is where the fun starts. But before we get there, lets walk through the code required to make the trivial example above actually functional.</p>

<p>First, we need to get our main camera rendering to a secondary texture. Usually when you want a camera to render to a texture in Unity you use the targetTexture attribute of the camera component, but not today. Unity is a bit quirky here, but I’ve found in practice that you can’t blit a texture to the frame buffer if that texture is currently a camera’s target texture. Since we’re going to be blitting this texture to the framebuffer as we apply our post effect, we need to use a different bit of api:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">public</span> <span class="k">class</span> <span class="nc">ScreenSpaceDistortionEffect</span> <span class="o">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="n">RenderTexture</span> <span class="n">screenRT</span><span class="p">;</span>
    <span class="n">Camera</span> <span class="n">mainCam</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">Awake</span><span class="p">()</span>
    <span class="p">{</span>
    	<span class="n">screenRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    	<span class="n">mainCam</span> <span class="o">=</span> <span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    	<span class="n">mainCam</span><span class="p">.</span><span class="n">SetTargetBuffers</span><span class="p">(</span><span class="n">screenRT</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">,</span> <span class="n">screenRT</span><span class="p">.</span><span class="n">depthBuffer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">OnPostRender</span><span class="p">()</span>
    <span class="p">{</span>
    	<span class="n">Graphics</span><span class="p">.</span><span class="n">Blit</span><span class="p">(</span><span class="n">screenRT</span><span class="p">,</span> <span class="p">(</span><span class="n">RenderTexture</span><span class="p">)</span><span class="n">null</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>The SetTargetBuffers call is how we are going to work around the targetTexture weirdness, if you attach this component to your main camera object, you should see that nothing is different in your game view than before we wrote this script, but behind the scenes, we have ourselves a nice easy to work with RenderTexture for our game. Which is perfect!</p>

<p>Now all we need to do is distort that texture. If you look at <a href="http://docs.unity3d.com/ScriptReference/Graphics.Blit.html">the docs</a> for Graphics.Blit, you’ll find that you can specify a material. If you think of Graphics.Blit like a full screen quad, then the material you specify here is just the material on that Quad. Blit automatically sets the _MainTex property of this material to your source render texture. Since all we need to do is modify the texture coordinates that we map to the screen, we can get by with a pretty simple material. The example above uses the following:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">vOUT</span> <span class="nf">vert</span><span class="p">(</span><span class="n">vIN</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vOUT</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">texcoord</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">vOUT</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">COLOR</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">fixed2</span><span class="p">(</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span><span class="o">*</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>I’m going to call this shader our “composite” shader, since it’s what we’re going to use to combine data about how to render the distortion effect with our regular camera view.</p>

<p>Now you just need to modify the earlier c# code to use this new shader, and you should see exactly the same type of effect across your screen.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">RenderTexture</span> <span class="n">screenRT</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">mainCam</span><span class="p">;</span>
<span class="n">Material</span> <span class="n">effectMaterial</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Awake</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">screenRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">mainCam</span> <span class="o">=</span> <span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">mainCam</span><span class="p">.</span><span class="n">SetTargetBuffers</span><span class="p">(</span><span class="n">screenRT</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">,</span> <span class="n">screenRT</span><span class="p">.</span><span class="n">depthBuffer</span><span class="p">);</span>

    <span class="n">effectMaterial</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Material</span><span class="p">(</span><span class="n">Shader</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="s">"Custom/Composite"</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">OnPostRender</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="n">Blit</span><span class="p">(</span><span class="n">screenRT</span><span class="p">,</span> <span class="p">(</span><span class="n">RenderTexture</span><span class="p">)</span><span class="n">null</span><span class="p">,</span> <span class="n">effectMaterial</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>Voila! We now officially have our post effect working!</p>

<h2>An Actually Useful Implementation</h2>

<p>Now that we have the basics down, it’s time for us to decide how we should go about modifying our screen uvs. Unless you’re going for some sort of drug trip / dream sequence effect, performing arithmetic on the uvs alone is likely not going to cut it. Today we’re going to create a secondary screen buffer (the “shield” buffer), and draw our shield(s) into it using a replacement shader. We’ll then use the contents of that buffer to deform our screen uvs.</p>

<p>But before we get to the replacement shader, let’s just render our shield as is into the secondary buffer (to make sure the buffer is working at all).</p>

<p>We’re going to be modifying our C# script again. We need to create the second render texture for the shield, but we don’t need this one to be at full screen res, since we aren’t going to be actually using it for colours in the framebuffer, and it’s much lighter on your gpu to only draw into the smaller buffer. Then we need to set up our camera, and get it rendering into this buffer. Here’s what that looks like:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">RenderTexture</span> <span class="n">shieldRT</span><span class="p">;</span>
<span class="n">RenderTexture</span> <span class="n">screenRT</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">distortCam</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">mainCam</span><span class="p">;</span>
<span class="n">Material</span> <span class="n">effectMaterial</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Awake</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">screenRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">screenRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">shieldRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">shieldRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">effectMaterial</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Material</span><span class="p">(</span><span class="n">Shader</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="s">"Custom/Composite"</span><span class="p">));</span>

    <span class="n">mainCam</span> <span class="o">=</span> <span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">mainCam</span><span class="p">.</span><span class="n">SetTargetBuffers</span><span class="p">(</span><span class="n">screenRT</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">,</span> <span class="n">screenRT</span><span class="p">.</span><span class="n">depthBuffer</span><span class="p">);</span>

    <span class="n">distortCam</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="s">"DistortionCam"</span><span class="p">).</span><span class="n">AddComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">OnPostRender</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">mainCam</span><span class="p">);</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">grey</span><span class="p">;</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">cullingMask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="n">NameToLayer</span><span class="p">(</span><span class="s">"Shield"</span><span class="p">);</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">targetTexture</span> <span class="o">=</span> <span class="n">shieldRT</span><span class="p">;</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">Render</span> <span class="p">();</span>

    <span class="n">effectMaterial</span><span class="p">.</span><span class="n">SetTexture</span><span class="p">(</span><span class="s">"_DistortionTex"</span><span class="p">,</span> <span class="n">shieldRT</span><span class="p">);</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="n">Blit</span><span class="p">(</span><span class="n">screenRT</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">effectMaterial</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>If you run this now (and make the shieldRT public), you’ll be able to see that we are successfully drawing into our shield buffer, but our effect shader isn’t doing anything useful with that data yet, so let’s look at that next. For this initial step, let’s modify the composite shader to simply subtract the G and B values of the distortion texture from the screen uvs:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">sampler2D</span> <span class="n">_DistortionTex</span><span class="p">;</span>
<span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">vOUT</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">COLOR</span>
<span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">distort</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_DistortionTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">fixed2</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="p">(</span><span class="n">distort</span><span class="p">.</span><span class="n">gb</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)));</span>
    <span class="k">return</span> <span class="n">tex</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>If you hit run now, this is what the sample scene should look like:</p>

<div align="center">
<img src="/images/post_images/2016-1-15/checkerdistort.gif" />
<br />
<br />
</div>

<p>Not exactly what we’re after - but at least it’s interesting!</p>

<p>Now that we’ve proven that the secondary buffer is working, it’s time to think about how we want our shield to look. When I think of a force field, I think of it as energy repelling things away from whatever is inside the shield. So I think I’d like my shield to communicate that visually. Let’s shift the UVs on the edge of the shield away from the center of the circle.</p>

<p>To do this, we’re going to use a replacement shader, which is going to swap the shader on our shield bubbles when they’re rendered by our distortion camera. This will let us write the data we need to our secondary buffer without changing how the bubble looks in game.</p>

<p>Let’s use the following as a starting point:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">CGPROGRAM</span>
<span class="cp">#pragma vertex vert
#pragma fragment frag
#include "ShieldEffect.cginc"
</span>
<span class="k">struct</span> <span class="n">vIN</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">texcoord</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vOUT</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">oPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">wPos</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">wNorm</span> <span class="o">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">objPos</span> <span class="o">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>

<span class="n">vOUT</span> <span class="nf">vert</span><span class="p">(</span><span class="n">vIN</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vOUT</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">zeroPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">));</span>
    <span class="n">o</span><span class="p">.</span><span class="n">wPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">_Object2World</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>				
    <span class="n">o</span><span class="p">.</span><span class="n">wNorm</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">fixed4</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">_World2Object</span><span class="p">).</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">objPos</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">oPos</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">zeroPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">vOUT</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">COLOR</span>
<span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">oPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="n">i</span><span class="p">.</span><span class="n">oPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">CalcShieldIntensity16</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">objPos</span><span class="p">);</span>

    <span class="n">float3</span> <span class="n">viewdir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">wPos</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">ang</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">viewdir</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">wNorm</span><span class="p">)</span> <span class="o">+</span> <span class="n">intensity</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">tex</span> <span class="o">*</span>  <span class="n">ang</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ENDCG</span></code></pre></div>

<p>Before we go about plumbing this in to our game, let’s talk about what’s going on here. First, since we want our effect to look the same no matter what angle we’re viewing from, it simplifies a lot of things if we work in screenspace for generating the actual colours that we’re writing to the buffer. What we want is for the colours we write to be representative of their direction from the center of the shield, so to do that, we transform the origin point of the object (the zeroPos variable) into screen space as well, and then subtract that point from our vertex’s position in screen space. This gives us a nice direction vector to work with.</p>

<p>In the fragment shader, we turn this direction vector into a colour, and we use a rim light calculation to attenuate the colours towards the center of the shield (since the normals for the center of the screen space sphere will always point towards the camera). Then we add 0.5 to everything, so that we can use this buffer to distort things in both directions in U,V space (since you can’t write a negative colour into a buffer). This means that any pixel in the buffer which is written out as 128,128,128 will do nothing, but values above and below are valid.</p>

<p>Finally, we add the intensity calculation to our fragment so that our impacts can distort more along their edges. This obviously won’t be 100% accurate because the direction of the distortion isn’t really being taken into account, but it creates a good looking effect anyway. You could spend more time making sure that the impact bubbles distort in a consistent way out from their center, but for brevity’s sake I’m not going to in this post.</p>

<p>This is going to give us a shield buffer that looks something like this (assuming 2 shields on screen):</p>

<div align="center">
<img src="/images/post_images/2016-1-15/shield_buffer.png" />
<br />
<br />
</div>

<p>Now all we need to do is get the replacement shader working. Just get the shader into your script the same way we loaded in the Composite shader, and make this really simple 1 line change to the Render call in OnPostRender:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">distortCam</span><span class="p">.</span><span class="n">RenderWithShader</span><span class="p">(</span><span class="n">shieldReplacementShader</span><span class="p">,</span> <span class="n">null</span><span class="p">);</span></code></pre></div>

<p>And with that, we should have the following!</p>

<div align="center">
<img src="/images/post_images/2016-1-15/second_distort.gif" />
<br />
<br />
</div>

<p>Note that you may find that the effect is too intense even with the replacement shader (this is extremely noticeable if you’re working with the scene I gave you at the beginning of the article). In that case you may want to tone down the intensity of the effect by adding a multiplication into the compostie shader:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">fixed4</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">fixed2</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="p">(</span><span class="n">distort</span><span class="p">.</span><span class="n">gb</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="p">));</span></code></pre></div>

<p>if you’re following along at home, the your sample scene should look like this if you grab your shield and move it around:</p>

<div align="center">
<img src="/images/post_images/2016-1-15/checkertranslate.gif" />
<br />
<br />
</div>

<p>You may also notice that the edges of your shield bubble are now a little bit jagged. This is because we’re rendering to a smaller buffer for the shield effect. This can be alleviated by increasing the size of the shield renderTexture (which is EXTREMELY expensive), or doing some sort of blur operation on your shield buffer (probably less expensive). However we’re not going to worry about it today because by the end of the article we’re going to have an approach that hides this jagginess.</p>

<p>This is great and all, but now our shield looks all weird since we’re distorting the UVs that it’s being drawn with too. I’d like to preserve the nice plasma texture on the shield, so I’m going to move the actual rendering of the shield to a different camera, and make sure the camera that we’re distorting the UVs on doesn’t see objects on the shield layer. This is really easy to do, but will leave us with a different problem. We’ll get to that in a second.</p>

<p>First, let’s modify our c# effect script to create this new camera for us:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">RenderTexture</span> <span class="n">shieldRT</span><span class="p">;</span>
<span class="n">RenderTexture</span> <span class="n">screenRT</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">distortCam</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">mainCam</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">shieldCam</span><span class="p">;</span>

<span class="n">Shader</span> <span class="n">shieldReplacementShader</span><span class="p">;</span>
<span class="n">Material</span> <span class="n">effectMaterial</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Awake</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">screenRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">screenRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">shieldRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">shieldRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">shieldReplacementShader</span> <span class="o">=</span> <span class="n">Shader</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="s">"Custom/Replacement"</span><span class="p">);</span>
    <span class="n">effectMaterial</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Material</span><span class="p">(</span><span class="n">Shader</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="s">"Custom/Composite"</span><span class="p">));</span>

    <span class="n">mainCam</span> <span class="o">=</span> <span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">mainCam</span><span class="p">.</span><span class="n">SetTargetBuffers</span><span class="p">(</span><span class="n">screenRT</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">,</span> <span class="n">screenRT</span><span class="p">.</span><span class="n">depthBuffer</span><span class="p">);</span>
    <span class="n">mainCam</span><span class="p">.</span><span class="n">cullingMask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="n">NameToLayer</span><span class="p">(</span><span class="s">"Shield"</span><span class="p">));</span>

    <span class="n">distortCam</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="s">"DistortionCam"</span><span class="p">).</span><span class="n">AddComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">shieldCam</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="s">"Shield Cam"</span><span class="p">).</span><span class="n">AddComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">cullingMask</span> <span class="o">=</span> <span class="n">distortCam</span><span class="p">.</span><span class="n">cullingMask</span><span class="p">;</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">clearFlags</span> <span class="o">=</span> <span class="n">CameraClearFlags</span><span class="p">.</span><span class="n">Depth</span><span class="p">;</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">mainCam</span><span class="p">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">mainCam</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">mainCam</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">rotation</span><span class="p">;</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">cullingMask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="n">NameToLayer</span><span class="p">(</span><span class="s">"Shield"</span><span class="p">);</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">fieldOfView</span> <span class="o">=</span> <span class="n">mainCam</span><span class="p">.</span><span class="n">fieldOfView</span><span class="p">;</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">orthographic</span> <span class="o">=</span> <span class="n">mainCam</span><span class="p">.</span><span class="n">orthographic</span><span class="p">;</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">orthographicSize</span> <span class="o">=</span> <span class="n">mainCam</span><span class="p">.</span><span class="n">orthographicSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">OnPostRender</span><span class="p">(){...}</span></code></pre></div>

<p>Notice that we also added a line to remove the Shield layer from the main camera’s culling mask. Now that we have a second camera doing this for us, that camera doesn’t need to create draw calls to incorrectly render the shield colour.</p>

<div align="center">
<img src="/images/post_images/2016-1-15/third_distort.gif" />
<br />
<br />
</div>

<p>With this change, our shield looks a lot better, but like I said, this has exacerbated another problem we have. Earlier we accepted that our distortion effect wasn’t going to have depth information, and therefore would distort things in front of the shield, but now, we also don’t have depth information for the shield colour itself, which means that shields will render on top of everything else. This is much more noticeable, and makes this effect really unwieldy, so we’re going to have to do something about that.</p>

<div align="center">
<img src="/images/post_images/2016-1-15/depth_problem.png" />
<br />
<br />
</div>

<h2>From Full Screen Effect to Projective Texturing</h2>

<p>Buckle up, things are about to get fun.</p>

<p>All the problems that we have right now are due to us treating the shields like they aren’t geometry: we’re rendering them to a buffer to distort the whole screen, and then using a secondary camera which has no depth information to paste them over the rest of the game. Wouldn’t it be great if we could use our depth buffer to occlude both the distortion and colours of the shield?</p>

<p>In the past, I’ve seen this done by manually calculating a depth pass, but this is expensive and requires you to double the draw calls of everything you want included in the depth buffer that you’re going to use to occlude your warp effect; so instead of doing that, here’s what we’re going to do today:</p>

<ul>
  <li>Render the main camera (without warp) to a render texture</li>
  <li>Render the multi colored shield buffer as usual</li>
  <li>Copy the main camera render texture to the buffer that the shield camera will draw into</li>
  <li>Share a depth buffer between our main camera and our shield camera so that our shields are occluded properly without incurring extra draw calls</li>
  <li>Continue to render our shields after everything else, but pass the main camera render texture to our shield shaders, and let them deal with the warp effect themselves so that when the shield is occluded, the warp effect is occluded too</li>
  <li>Blit the shield camera render texture to the screen</li>
</ul>

<p>It’s a lot of changes, but at the end of the day we’re going to end up with a really really easy to use shield bubble effect that behaves exactly like we expect it should without incurring extra draw calls or doing a lot of extra full screen operations. So without further ado, let’s take it from the top!</p>

<h3>Rendering the main camera to a render texture</h3>

<p>The first part of this list should be pretty easy after all the work with render textures we did above. In fact we’re already rendering the main camera to a render texture (the screenRT) so we’re actually in good shape.</p>

<p>First of all, we need to stop our main camera from blitting to the screen, and we need to set our offscreen buffer to a global shader uniform so we can access it later. We’re going to change the our OnPostRender function in our c# script from this:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">OnPostRender</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">effectMaterial</span><span class="p">.</span><span class="n">SetTexture</span><span class="p">(</span><span class="s">"_DistortionTex"</span><span class="p">,</span> <span class="n">shieldRT</span><span class="p">);</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="n">Blit</span><span class="p">(</span><span class="n">screenRT</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">effectMaterial</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>To this:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">OnPostRender</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Shader</span><span class="p">.</span><span class="n">SetGlobalTexture</span><span class="p">(</span><span class="s">"_DistortionBuffer"</span><span class="p">,</span> <span class="n">shieldRT</span><span class="p">);</span>
    <span class="n">Shader</span><span class="p">.</span><span class="n">SetGlobalTexture</span><span class="p">(</span><span class="s">"_ScreenBuffer"</span><span class="p">,</span> <span class="n">screenRT</span><span class="p">);</span>

    <span class="n">Graphics</span><span class="p">.</span><span class="n">Blit</span><span class="p">(</span><span class="n">screenRT</span><span class="p">,</span> <span class="n">finalRT</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>One important thing to note here is that if you want objects which have warp be be seen through each other, you’re going to have to render them to this buffer. For our shields, the easiest way to do this is to create a duplicate shield sphere, assign it the optimized (non warp) shader, child it to the original shield sphere and make sure it isn’t on the Shield layer. This isn’t going to work in all cases, but it will for our purposes today.</p>

<p>Notice that we’re no longer going to be setting properties of the composite material. This is because with our new approach, the composite material’s logic is going to be handled by the shield shader, so we don’t actually need the composite any more.</p>

<p>You may also have noticed that the code above references a new RenderTexture. About that:</p>

<h3>Two New RenderTextures</h3>

<p>Step three and four of our new technique hint at some new render textures that we’re going to need. The first of which is our finalRT. This is the render texture that the camera rendering our warp objects will write into. We’ve already got the code to copy our main camera’s output into that texture like we said we’d do, but we also need to set up this render texture. We also need to set up a render texture specifically for storing the depth buffer from the main camera so that we can pass that to our shield camera as well.</p>

<p>Our new Awake function should look like the following:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">RenderTexture</span> <span class="n">shieldRT</span><span class="p">;</span>
<span class="n">RenderTexture</span> <span class="n">screenRT</span><span class="p">;</span>
<span class="n">RenderTexture</span> <span class="n">finalRT</span><span class="p">;</span>
<span class="n">RenderTexture</span> <span class="n">depthRT</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">distortCam</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">mainCam</span><span class="p">;</span>
<span class="n">Camera</span> <span class="n">shieldCam</span><span class="p">;</span>

<span class="n">Shader</span> <span class="n">shieldReplacementShader</span><span class="p">;</span>
<span class="n">Material</span> <span class="n">effectMaterial</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Awake</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">screenRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">screenRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">finalRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">finalRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">depthRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Depth</span><span class="p">);</span>
    <span class="n">depthRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">shieldRT</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span>
    <span class="n">shieldRT</span><span class="p">.</span><span class="n">wrapMode</span> <span class="o">=</span> <span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Repeat</span><span class="p">;</span>

    <span class="n">shieldReplacementShader</span> <span class="o">=</span> <span class="n">Shader</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="s">"Custom/Replacement"</span><span class="p">);</span>

    <span class="n">mainCam</span> <span class="o">=</span> <span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">mainCam</span><span class="p">.</span><span class="n">SetTargetBuffers</span><span class="p">(</span><span class="n">screenRT</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">,</span> <span class="n">depthRT</span><span class="p">.</span><span class="n">depthBuffer</span><span class="p">);</span>
    <span class="n">mainCam</span><span class="p">.</span><span class="n">cullingMask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LayerMask</span><span class="p">.</span><span class="n">NameToLayer</span><span class="p">(</span><span class="s">"Shield"</span><span class="p">));</span>

    <span class="n">distortCam</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="s">"DistortionCam"</span><span class="p">).</span><span class="n">AddComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">distortCam</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">shieldCam</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="s">"Shield Cam"</span><span class="p">).</span><span class="n">AddComponent</span><span class="o">&lt;</span><span class="n">Camera</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">SetTargetBuffers</span><span class="p">(</span><span class="n">finalRT</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">,</span> <span class="n">depthRT</span><span class="p">.</span><span class="n">depthBuffer</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span></code></pre></div>

<p>Excellent! Now we have to make sure that our shieldCam is set to not clear anything before it renders, since we now are very deliberately populating it’s buffers with data from our main camera:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">shieldCam</span><span class="p">.</span><span class="n">clearFlags</span> <span class="o">=</span> <span class="n">CameraClearFlags</span><span class="p">.</span><span class="n">Nothing</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span></code></pre></div>

<p>And finally, you may notice that we’re not actually drawing anything to the screen anymore. We need to tell our shieldCam that it’s cool to render everything to the frame buffer when it’s done. I like to keep as much of the logic for an effect within the same script as I can, so I did this by adding a new function to our effect script, and putting a component on the shield camera to call this inside an OnPostRenderCall. You can find a scene with everything set up like this in the code dump at the end of the article.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">public</span> <span class="kt">void</span> <span class="nf">BlitToScreen</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="n">Blit</span><span class="p">(</span><span class="n">finalRT</span><span class="p">,</span> <span class="p">(</span><span class="n">RenderTexture</span><span class="p">)</span><span class="n">null</span><span class="p">);</span>
    <span class="n">screenRT</span><span class="p">.</span><span class="n">DiscardContents</span><span class="p">();</span>
    <span class="n">finalRT</span><span class="p">.</span><span class="n">DiscardContents</span><span class="p">();</span>
    <span class="n">shieldRT</span><span class="p">.</span><span class="n">DiscardContents</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>

<p>Notice that we also clear the contents of our render textures in this function.</p>

<h3>Warping Inside our Fragment Shaders</h3>

<p>There’s one last thing we need to do to finish this effect, and that’s to move the logic that used to live in our composite shader to the shader we use to draw our shields. There’s a completed shader at the end of this article but all we’re doing is adding uniforms to the shader so we can see the screenRT and shieldRT (the warp buffer), and then filling in areas of our object that would be transparent if we were alpha blending with a distorted lookup into screenRT. The addition to the fragment shader looks like this:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="n">float3</span> <span class="n">viewdir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">ang</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">viewdir</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">))));</span>
    <span class="n">half4</span> <span class="n">rimCol</span> <span class="o">=</span> <span class="n">_RimColor</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">_RimPower</span><span class="p">)</span> <span class="o">*</span> <span class="n">_RimIntensity</span><span class="p">;</span>

    <span class="n">half4</span> <span class="n">texColor</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">tex</span> <span class="o">=</span>  <span class="n">rimCol</span> <span class="o">*</span> <span class="n">texColor</span><span class="p">;</span>

    <span class="n">float4</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">ComputeScreenPos</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">objectPos</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">distortion</span> <span class="o">=</span> <span class="n">tex2Dproj</span><span class="p">(</span><span class="n">_DistortionBuffer</span><span class="p">,</span> <span class="n">UNITY_PROJ_COORD</span><span class="p">(</span><span class="n">screen</span><span class="p">));</span>

    <span class="n">float4</span> <span class="n">screenPos</span> <span class="o">=</span> <span class="n">screen</span><span class="p">;</span>				
    <span class="n">screenPos</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span>  <span class="n">screenPos</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="p">(</span><span class="n">distortion</span><span class="p">.</span><span class="n">rb</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">;</span>

    <span class="n">float4</span> <span class="n">d</span> <span class="o">=</span> <span class="n">tex2Dproj</span><span class="p">(</span><span class="n">_ScreenBuffer</span><span class="p">,</span> <span class="n">UNITY_PROJ_COORD</span><span class="p">(</span><span class="n">screenPos</span><span class="p">));</span>
    <span class="k">return</span>  <span class="n">tex</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="n">texColor</span> <span class="o">*</span> <span class="n">CalcShieldIntensity16</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">oPos</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>The ComputeScreenPos and UNITY_PROJ_COORD macros do most of the hard work for us here, but you can see where we’ve basically lifted the logic completely from the composite shader and added it here. This is going to make our 100% opaque objects look like they’re alpha blending with a warp effect. It also lets our war effect be occluded by geometry, by other warp effects, and if you took my advice and wrote out a non warp version of shield to the main camera, you can see one shield through another. All of this put together might look something like this:</p>

<div align="center">
<img src="/images/post_images/2016-1-15/spaceshipfinal.gif" />
<br />
<br />
</div>

<p>When you look at the final shader I have posted in the google drive, you’ll also notice that I’ve added a second pass to it so that we can properly show the shield impacts on the side of the shield behind the ship we’re looking at. I skipped over the distortion effect in that pass to make it a bit more performant, but I wanted to keep the shield impacts so that the player could see all the direction that they were being shot at from. Again, this is open to interpretation, as it does make the shader much more expensive.</p>

<p>And At last, that’s everything!</p>

<h2>How Expensive Is This</h2>

<p>So the inevitable question that’s always (rightly) asked about cool graphics code is “how expensive is it?” So before we wrap up for today, let’s do a quick performance analysis of our new shield versus the original shield posted and figure out exactly what using either of them means for our performance. Since virutally all my Unity experience is on mobile, let’s look at this like our intended target is a mobile device.</p>

<p>On the draw call front, the original shader from Warfleet comes in the lowest, with a single draw call. This is followed by my optimized version of the shader, which I added a draw call to so that we could render the inside/back face of the sphere’s impacts as well. Our post effect version comes in last, with a draw call to render the shield to our buffer, and 1 draw call per side of the shield that we’re rendering.</p>

<p>It’s worth noting that if all you’re looking for is a more performant version of the original effect, you could remove the back face pass in the optimized version and be there.</p>

<p>Finally, I’ve set up a small test scene to see what the on device cost of the effect is. The scene is simple enough, whenever I tap the screen I spawn another instance of the shield and offset it a bit from the first one. I’ve turned on the on board profiler on an iPhone 6 to grab the performance data over time. It’s not a perfect test, but the test scene is consistent across every shader so at least the numbers will be useful. Here are the results:</p>

<div align="center">
<img src="/images/post_images/2016-1-15/performance.png" />
<br />
<br />
</div>

<p>Remember that these results are on a metal capable device (which means the cost of a draw call is lower than you’d see on OpenGL), these numbers are only useful relative to each other, and not as an absolute measure of the cost of these shaders on any device except the iPhone 6.</p>

<h2>Conclusion</h2>

<p>That should do it, as said above, the source for everything here can be found on google drive <a href="https://drive.google.com/folderview?id=0B85AH3b17yxpaHRrVVVVWmpnNVk&amp;usp=sharing">here</a>. Hopefully this has been helpful enough that you don’t feel limited to just making sci fi shields, but feel like you can go forth and create refraction shaders, heat haze, whatever!</p>

<p>If you have any questions about anything, spot a mistake, or just want to say hi, send me a message <a href="http://twitter.com/khalladay">on twitter</a>.</p>

<p>Happy shading!</p>

</div>

<div id="related">
  <h3>Recent Posts</h3>
  <ul class="posts">
    
    <li>
      <span>13 Dec 2017 &raquo;</span> <a href="/blog/tutorial/2017/12/13/Custom-Allocators-Vulkan.html">A Simple Device Memory Allocator For Vulkan</a>
    </li>
    
    <li>
      <span>27 Nov 2017 &raquo;</span> <a href="/blog/tutorial/2017/11/27/Vulkan-Material-System.html">Lessons Learned While Building a Vulkan Material System</a>
    </li>
    
    <li>
      <span>30 Aug 2017 &raquo;</span> <a href="/blog/tutorial/vulkan/2017/08/30/Vulkan-Uniform-Buffers-pt2.html">Improving Vulkan Breakout</a>
    </li>
    
    <li>
      <span>13 Aug 2017 &raquo;</span> <a href="/blog/tutorial/vulkan/2017/08/13/Vulkan-Uniform-Buffers.html">Comparing Uniform Data Transfer Methods in Vulkan</a>
    </li>
    
  </ul>
</div>


      <div class="footer">
        <div class="disclaimer">
  
  <p>
    The postings on this site are my own and don't necessarily represent my 
    employer’s positions, strategies or opinions.
  </p>
  

  <p>
    © Kyle Halladay, 2014 &mdash; built with <a href="http://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/swanson/lagom">Lagom theme</a>
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40292745-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
