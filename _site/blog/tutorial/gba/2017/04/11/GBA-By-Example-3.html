<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kyle Halladay - GBA By Example - Drawing and Moving Backgrounds</title>
  <meta name="author" content="Kyle Halladay" />
  <meta name="description" content="I build shaders, renderers, games, and other stuff that's fun to stare at." />
  <link rel="canonical" href="http://kylehalladay.com/blog/tutorial/gba/2017/04/11/GBA-By-Example-3.html" />
  <meta name="keywords" content="life,code,software,development,games,graphics,shaders,indie" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Kyle Halladay" href="http://kylehalladay.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.jpg" id="logo" alt="Blog logo"/>
  </a>
  <h2>I'm <a href="/">Kyle Halladay</a>.</h2>
  <div id="bio">
    <p>I build shaders, graphics tech, and art pipelines for games. </p>
    <p>I also dabble in GBA dev, you can find my tutorials <a href="/gba.html">here.</a>
    <p>Check out <a href="/archive.html">some other stuff I've written</a></p>
  </div>
  <div id="social">
    Want to say hi?
<div id="stalker">
  
  <a title="khalladay on Github" href="https://github.com/khalladay">
    <i class="fa fa-github-square"></i>
  </a>
  

  

  

  

  

  
  <a title="khalladay on Twitter" href="https://twitter.com/khalladay">
    <i class="fa fa-twitter-square"></i>
  </a>
  

  

  

  
  <a title="Kyle Halladay on LinkedIn" href="https://www.linkedin.com/in/kylehalladay">
    <i class="fa fa-linkedin-square"></i>
  </a>
  

  

  
  <a title="Kyle Halladay via Email" href="mailto:k.mj.halladay@gmail.com">
    <i class="fa fa-envelope-square"></i>
  </a>
  

  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="fa fa-rss-square"></i>
  </a>
</div>

  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <topbar><div align="center"><h2><a href="/index.html" style="color:#000">KyleHalladay.com</a></h2></div>
      <div align="center" style="font-size:18px"><a href="/archive.html">Archive</a></div>
      <hr style="border-color:#000; margin:1em -0.25em;"></topbar>

      <p class="meta">

</p>

<h1 class="title">GBA By Example - Drawing and Moving Backgrounds</h1>

<div id="post">
  <p>(Note: This is Part 3 of my GBA by Example series. A list of my other GBA tutorials can be found <a href="http://kylehalladay.com/gba.html">here</a>)</p>

<p>It’s Tuesday, which means it’s the arbitrary day of the week I chose to post GBA stuff!</p>

<p><a href="http://kylehalladay.com/blog/tutorial/2017/04/04/GBA-By-Example-2.html">Last week</a> we got a sprite on the screen and moving around in a tiled video mode, but it still left our screen looking a little bit bare. This week we’re going to rectify that, and figure out how to work with <strong>Backgrounds</strong>! You can make really great looking stuff with backgrounds, or you can do what I did, and make something that looks like this:</p>

<div align="center">
<img src="/images/post_images/2017-04-11/bgscroll.gif" /><br />
</div>

<p>This is two backgrounds (one gradient, and one checkerboard), overlapping one another, and moving in opposite directions. Snazzy eh? Today we’re going to cover the absolute minimum you need to know to make something like that.</p>

<p>To kick things off, let’s take a look at what a background actually is on the GBA:</p>

<h2 id="introducing-backgrounds">Introducing Backgrounds</h2>

<p>Like Sprites, Backgrounds are rectangular collections of tiles. Unlike Sprites, they can be really, really big (relatively speaking). If you recall from last week, the largest sprite we can make is 64x64 pixels. Backgrounds can be up to 1024x1024 if we want them to. Since we only have 96k of VRAM on the GBA (and 32k of that is for Sprites), it stands to reason that to fit all our background data in, they look a bit different from Sprites in memory.</p>

<p>Just like with Sprites, all colours in a Background come from a Palette, which is a collection of up to 256 different colours, each stored as a 16 bit unsigned integer. Colours on the GBA are stored with 5 bits per channel, with the highest bit ignored, like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kr">inline</span> <span class="n">uint16</span> <span class="nf">MakeCol</span><span class="p">(</span><span class="n">uint32</span> <span class="n">red</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">green</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">blue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">red</span> <span class="o">|</span> <span class="p">(</span><span class="n">green</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">blue</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>In code, a Palette might be defined like so:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">bgPal</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span><span class="o">=</span>
<span class="p">{</span>
    <span class="mh">0x4DA0</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0xFFFF</span><span class="p">,</span><span class="mh">0x001F</span>
<span class="p">};</span></code></pre></div>

<p>One thing that hasn’t been mentioned in previous articles is that pixels that use the colour at index 0 are treated as transparent, so you only see the index 0 colour if nothing else gets drawn on top of that pixel. This will be important for us today because we’re going to overlap two backgrounds on top of each other.</p>

<p>A Background’s tiles are the same as a Sprite’s: 8x8 rectangular collections of indices, with each of these storing an index from the palette array. Backgrounds use a separate colour palette from sprites, so you can use an entirely different set of colours for your backgrounds than you do for other stuff in your game. This palette memory, just like with sprites, is large enough to store 256 colours. Since we can only have 256 possible values, tiles store each pixel as an 8 bit index. Tiles are laid out row by row, from top to bottom.</p>

<p>In code, that might look like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">bgTiles</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span><span class="o">=</span>
<span class="p">{</span>
    <span class="mh">0x0101</span><span class="p">,</span><span class="mh">0x0202</span><span class="p">,</span><span class="mh">0x0101</span><span class="p">,</span><span class="mh">0x0202</span><span class="p">,</span><span class="mh">0x0101</span><span class="p">,</span><span class="mh">0x0202</span><span class="p">,</span><span class="mh">0x0101</span><span class="p">,</span><span class="mh">0x0202</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre></div>

<p>If you store your tile data in values larger than uint8s, like I did above, remember that the lowest byte in a value is the leftmost pixel.</p>

<p>All of that should be familiar to you if you read <a href="http://kylehalladay.com/blog/tutorial/2017/04/04/GBA-By-Example-2.html">last week’s post</a>, but unlike with Sprites, the order of the tiles doesn’t matter when we’re working with backgrounds. This is because backgrounds want to re-use tiles as much as possible. To accomplish this, backgrounds use a third data structure, called a <em>Screen Block</em>, which is a collection of indices into tile memory: One 16 bit value for every 8x8 tile that the background uses.</p>

<p>Screen Blocks are always 32x32 in size, but each of these values represents an 8x8 tile, meaning that backgrounds are made up of one or more blocks of 256x256 pixels.</p>

<p>In code, a Screen Block might look something like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">checkerBg</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mh">0x0001</span><span class="p">,</span><span class="mh">0x0001</span><span class="p">,</span><span class="mh">0x0001</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>
    <span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>
    <span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x000A</span><span class="p">,</span><span class="mh">0x001D</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>
    <span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>

    <span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>
    <span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>
    <span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>
    <span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span>

    <span class="o">//</span><span class="k">continue</span> <span class="k">for</span> <span class="n">another</span> <span class="mi">30</span> <span class="n">rows</span></code></pre></div>

<p>As seen here, Screen Blocks are defined row by row, top to bottom, each value representing the index of a tile. When you’re working with 8bpp tiles, this is all there is to it. There’s more to think about in 4bpp mode, but since this is the first time we’re doing anything with bacgkrounds, let’s keep it simple and continue working in 8bpp mode.</p>

<p>The last thing to know is that we can only have between 0 and 4 backgrounds working at the same time. Yay hardware limitations!</p>

<p>This was a lot of theory, and I want to switch gears now and start to build some stuff, but just to recap:</p>

<ul>
  <li>A Background is a rectangular collection of 8x8 tiles</li>
  <li>Tiles are stored as arrays of indices into palette memory</li>
  <li>To decide which tile goes where, Backgrounds use Screen Blocks, which are 32x32 arrays of indices into tile memory</li>
  <li>A Background consists of one or more Screen Blocks</li>
  <li>We can use between 0 and 4 backgrounds at any given time</li>
</ul>

<p><br />
Alright, let’s start putting this into practice!</p>

<h2 id="my-data">My Data:</h2>

<p>Because Screen Blocks are so large, I’ve uploaded the data (including tiles and palette) that I’m going to use today <a href="https://gist.github.com/khalladay/5d292b8d4ee7668c461821079072300d">to github</a> instead of just including it here.</p>

<p>That gist contains all the information needed to get our first background (the checkerboard) onto the screen. We’ll generate the gradient background in code below.</p>

<h2 id="getting-data-into-vram">Getting Data into VRAM</h2>

<p>We know what our data is going to look like, but we haven’t yet covered where it’s going to go. Let’s start with Palette memory, since it’s going to be the most like what we’ve done before.</p>

<p>As mentioned above, Backgrounds use a different palette than Sprites, which naturally means that the background palette is located at a different place in memory:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include "tiles.h"
</span>
<span class="cp">#define MEM_BG_PALETTE    ((uint16*)(0x05000000))
#define MEM_OBJ_PALETTE   ((uint16*)(0x05000200))
</span>
<span class="kt">void</span> <span class="nf">UploadPaletteMem</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_BG_PALETTE</span><span class="p">,</span> <span class="n">bgPal</span><span class="p">,</span> <span class="n">bgPalLen</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>Perfect, the palette data was easy! Next we need to get our tiles into memory. You may recall from <a href="http://kylehalladay.com/blog/tutorial/2017/04/04/GBA-By-Example-2.html">last week</a> that the data for sprite tiles starts at the fifth tile-block in tile memory. This is because the first 4 of those blocks are reserved for backgrounds. So let’s put our tile data into the first one:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">uint16</span> <span class="n">Tile</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">Tile</span> <span class="n">TileBlock</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="cp">#define MEM_VRAM                ((volatile uint32*)0x6000000)
#define MEM_TILE                ((TileBlock*)0x6000000)
</span>
<span class="kt">void</span> <span class="nf">UploadTileMem</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bgTiles</span><span class="p">,</span> <span class="n">bgTilesLen</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>All of this is almost identical to last week, so let’s start doing something different and get our Screen Block data into memory. Screen blocks share memory with Tile memory. A Screen Block is 2048 bytes, which means that we can fit 8 of them into a single tile-block. It’s up to us to make sure that we don’t try to put a Screen Block and tile data into the same spot in memory.</p>

<p>If you’re using the example data, you’ll notice that we only have 2 tiles to upload into memory (a checkerboard tile, and a transparent tile), so it’s safe for us to just go 1 Screen Block away from the start of VRAM:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">uint16</span> <span class="n">ScreenBlock</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="cp">#define MEM_SCREENBLOCKS        ((ScreenBlock*)0x6000000)
</span>
<span class="kt">void</span> <span class="nf">UploadScreenBlock</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//checkerBg is the ScreenBlock data from the gist
</span>    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_SCREENBLOCKS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">checkerBg</span><span class="p">,</span> <span class="n">checkerBgLen</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>That should about do it for uploading the data we have for our tiles, but I also mentioned that I generated the gradient background in code. Here’s the code for that:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kr">inline</span> <span class="n">uint16</span> <span class="nf">MakeCol</span><span class="p">(</span><span class="n">uint32</span> <span class="n">red</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">green</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">blue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">red</span> <span class="o">|</span> <span class="p">(</span><span class="n">green</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">blue</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GenerateGradient</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//we've uploaded 4 colours to palette memory
</span>    <span class="c1">//so make sure we don't overwrite those
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">uint16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="p">((</span><span class="n">uint16</span><span class="o">*</span><span class="p">)(</span><span class="n">MEM_BG_PALETTE</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="n">i</span><span class="p">)))</span> <span class="o">=</span> <span class="n">MakeCol</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//every tile is 64 palette indices
</span>    <span class="c1">//we have 32 grayscale values from above
</span>    <span class="n">uint8</span> <span class="n">tile</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">uint16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">tile</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">tile</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//generate 2 screen blocks,
</span>    <span class="c1">//each gray value getting two tiles of width
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">block</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">uint16</span> <span class="n">screenBlock</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

        <span class="c1">//screen block data is row by row, top to bottom
</span>        <span class="k">for</span> <span class="p">(</span><span class="n">uint16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">uint16</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//each block gets 16 colours, 2 tiles wide for each
</span>                <span class="n">screenBlock</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">block</span><span class="o">*</span><span class="mi">16</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_SCREENBLOCKS</span><span class="p">[</span><span class="n">block</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">screenBlock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2048</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>I was torn on whether or not to include this in the post, but I think it’s a good example of another way of working with all the types of memory we’re wrangling to get data on the screen. It also gives us an opportunity to work with a background that uses more than 1 Screen Block, since the gradient is 2 Screen Blocks wide.</p>

<p>If the above code is unclear, that’s ok! I don’t think it was particularly common to generate background data like this anyway. If you want to follow along, just copy and paste the above code and pretend we uploaded that data the same way we did the other data, since it has nothing to do with understanding how the GBA handles backgrounds.</p>

<h2 id="turning-things-on">Turning Things On</h2>

<p>The hard part is officially over! All that’s left now is to tell the hardware to use the data we’re feeding it, and glue all the snippets we have together.</p>

<p>Let’s talk about our friend the display control register (0x04000000), in addition to doing things like setting a video mode, or enabling objects, this value is also used to enable or disable backgrounds.</p>

<p>We get to work with up to four backgrounds at a time on the GBA, and you can enable them like so:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define VIDEOMODE_0    0x0000
#define BACKGROUND_0   0x0100
#define BACKGROUND_1   0x0200
#define BACKGROUND_3   0x0400
#define BACKGROUND_4   0x0800
</span>
<span class="cp">#define REG_DISPLAYCONTROL     *((volatile uint16*)(0x04000000))
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">REG_DISPLAYCONTROL</span> <span class="o">=</span> <span class="n">VIDEOMODE_0</span> <span class="o">|</span> <span class="n">BACKGROUND_0</span> <span class="o">|</span> <span class="n">BACKGROUND_1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>We’re only going to use the first two backgrounds today, but you can turn on all four backgrounds, or only 1 and 3, or any other combination that you want to use.</p>

<p>Also, we’re still in VideoMode_0, this is because it’s the easiest tiled mode to understand, and we (I) still don’t know enough to actually use any of the features in the other tiled modes.</p>

<p>If you’re in a bitmap mode, you need to enable Background 2 in order for anything to appear on the screen, but as far as I know, you can’t actually do anything with it, it’s just a flag needed to make bitmap modes work.</p>

<h2 id="defining-our-backgrounds">Defining Our Backgrounds</h2>

<p>Just like with Sprites (err.. Objects that is), we need to set up a few values to define how the hardware should use our background data. Mercifully, backgrounds are actually much easier to work with than Sprites. They only need a single 16 bit value set.</p>

<p>Since there are only 4 backgrounds, these bits are at constant memory locations:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define REG_BG0_CONTROL        *((volatile uint16*)(0x04000008))
#define REG_BG1_CONTROL        *((volatile uint16*)(0x0400000A))
#define REG_BG2_CONTROL        *((volatile uint16*)(0x0400000C))
#define REG_BG3_CONTROL        *((volatile uint16*)(0x0400000E))</span></code></pre></div>

<p>What each bit in these values means is as follows:</p>

<div align="center">
<table style="border:1px solid black; width=600px; padding:2px;">
<colgroup>
<col width="200px" />
<col width="400px" />
</colgroup>
<thead style="border:1px solid black; background-color:#FF8854;">
<tr class="header">
<th>BG</th>
<th> 0x FEDC BA98 7654 3210</th>
</tr>
</thead>
<tbody>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td>FE</td>
<td style="border:1px solid black;">Size (defined below)</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">D</td>
<td>Ignored today (see <a href="http://www.coranac.com/tonc/text/regbg.htm">Tonc</a> for info)</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">CBA98</td>
<td>What Screen Block to start at</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">7</td>
<td>Color mode: (1 for 8bpp, 0 for 4bpp)</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">6</td>
<td>Ignored today (see <a href="http://www.coranac.com/tonc/text/regbg.htm">Tonc</a> for info)</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">54</td>
<td>Nothing, empty bits</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">32</td>
<td>Tile Block to use</td>
</tr>

<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">10</td>
<td>Z Depth</td>
</tr>
</tbody>
</table>
</div>
<p><br /></p>

<p>Just like with Sprites, the sizes for backgrounds use the bits above to select a value from another table, for backgrounds, this table is as follows:</p>

<div align="center">
<table style="border:1px solid black; width=480px; padding:2px;">
<colgroup>
<col width="100px" />
<col width="100px" />
</colgroup>
<thead style="border:1px solid black; background-color:#FF8854;">
<tr class="header">
<th>Bits</th>
<th> Size (in Tiles)</th>
</tr>
</thead>
<tbody>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td>00</td>
<td style="border:1px solid black;">32x32</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">01</td>
<td>64x32</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">10</td>
<td>32x64</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">11</td>
<td>64x64</td>
</tr>
</tbody>
</table>
</div>
<p><br /></p>

<p>Using the above tables, if we wanted to define our first background (the checkerboard), as a 32x32 tile background which uses tiles starting at the first tile block, and uses the second Screen Block (since it’s offset from the start of VRAM to make space for tile memory), we would do the following:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">//Size 00, Screen Block 1, Color Mode 1, Tile Block 0, Depth 0
//0000 0001 1000 0000
</span>
<span class="n">REG_BG0_CONTROL</span> <span class="o">=</span> <span class="mh">0x0180</span><span class="p">;</span></code></pre></div>

<p>Notice that we want our Z Depth to be 0 as well. The higher this value, the farther back in the drawing order a background is, so a BG at depth 0 will draw on top of backgrounds with any higher values. Since our checkerboard background has the transparent pixels in it, we want it to be drawn on top of whatever will fill in those transparent pixels.</p>

<p>If we put all this together (leaving out the code for the second background), we get:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;string.h&gt;
#include "tiles.h"
</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>      <span class="n">uint8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>     <span class="n">uint16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">uint32</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">uint16</span> <span class="n">ScreenBlock</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">uint16</span> <span class="n">Tile</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">Tile</span> <span class="n">TileBlock</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="cp">#define VIDEOMODE_0    0x0000
#define BACKGROUND_0   0x0100
</span>
<span class="cp">#define REG_DISPLAYCONTROL     *((volatile uint16*)(0x04000000))
#define REG_BG0_CONTROL        *((volatile uint32*)(0x04000008))
</span>
<span class="cp">#define MEM_VRAM                ((volatile uint32*)0x6000000)
#define MEM_TILE                ((TileBlock*)0x6000000)
#define MEM_SCREENBLOCKS        ((ScreenBlock*)0x6000000)
</span>
<span class="cp">#define MEM_BG_PALETTE          ((uint16*)(0x05000000))
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//load data
</span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_BG_PALETTE</span><span class="p">,</span> <span class="n">bgPal</span><span class="p">,</span> <span class="n">bgPalLen</span> <span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bgTiles</span><span class="p">,</span> <span class="n">bgTilesLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_SCREENBLOCKS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">checkerBg</span><span class="p">,</span> <span class="n">checkerBgLen</span><span class="p">);</span>

    <span class="n">REG_BG0_CONTROL</span> <span class="o">=</span> <span class="mh">0x0180</span><span class="p">;</span><span class="c1">// 0000 0001 1000 0000;
</span>    <span class="n">REG_DISPLAYCONTROL</span> <span class="o">=</span>  <span class="n">VIDEOMODE_0</span> <span class="o">|</span> <span class="n">BACKGROUND_0</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>And if you run that, you should see:</p>

<div align="center">
<img src="/images/post_images/2017-04-11/bg0.png" /><br />
</div>

<p>Which is excellent! We officially have our first background on the screen. Let’s add our second one now. Remember that we used 2 Screen Blocks to hold all the values for this background, and we want them laid out horizontally, so we’ll have a 64x32 background. We want it to be at priority 0, and use the data we populated with the gradient generating code above.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Size 01, Screen Block 2, Color Mode 1, Tile Block 1, Priority 1
</span> <span class="c1">// 0100 0010 1000 0101
</span><span class="n">REG_BG1_CONTROL</span> <span class="o">=</span> <span class="mh">0x4285</span><span class="p">;</span></code></pre></div>

<p>If we add the above line, and the required #defines and gradient code to what we have, we get the following (I’ve omitted GenerateGradient() function body for brevity). I promise after this to not paste any more large code blocks into the article :)</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;string.h&gt;
#include "tiles.h"
#include "bg.h"
</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>      <span class="n">uint8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>     <span class="n">uint16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">uint32</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">uint16</span> <span class="n">ScreenBlock</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">uint16</span> <span class="n">Tile</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">Tile</span> <span class="n">TileBlock</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="cp">#define VIDEOMODE_0    0x0000
#define BACKGROUND_0   0x0100
#define BACKGROUND_1   0x0200
</span>
<span class="cp">#define REG_DISPLAYCONTROL     *((volatile uint16*)(0x04000000))
#define REG_BG0_CONTROL        *((volatile uint16*)(0x04000008))
#define REG_BG1_CONTROL        *((volatile uint16*)(0x0400000A))
</span>
<span class="cp">#define MEM_VRAM                ((volatile uint32*)0x6000000)
#define MEM_TILE                ((TileBlock*)0x6000000)
#define MEM_SCREENBLOCKS        ((ScreenBlock*)0x6000000)
</span>
<span class="cp">#define MEM_BG_PALETTE          ((uint16*)(0x05000000))
#define MEM_PALETTE             ((uint16*)(0x05000200))
</span>
<span class="kr">inline</span> <span class="n">uint16</span> <span class="nf">MakeCol</span><span class="p">(</span><span class="n">uint32</span> <span class="n">red</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">green</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">blue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">red</span> <span class="o">|</span> <span class="p">(</span><span class="n">green</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">blue</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">GenerateGradient</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//load data
</span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_BG_PALETTE</span><span class="p">,</span> <span class="n">bgPal</span><span class="p">,</span> <span class="n">bgPalLen</span> <span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bgTiles</span><span class="p">,</span> <span class="n">bgTilesLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_SCREENBLOCKS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">checkerBg</span><span class="p">,</span> <span class="n">checkerBgLen</span><span class="p">);</span>

    <span class="n">GenerateGradient</span><span class="p">();</span>

    <span class="n">REG_BG0_CONTROL</span> <span class="o">=</span> <span class="mh">0x0180</span><span class="p">;</span><span class="c1">// 0000 0001 1000 0000;
</span>    <span class="n">REG_BG1_CONTROL</span> <span class="o">=</span> <span class="mh">0x4285</span><span class="p">;</span> <span class="c1">// 0100 0010 1000 0101
</span>    <span class="n">REG_DISPLAYCONTROL</span> <span class="o">=</span>  <span class="n">VIDEOMODE_0</span> <span class="o">|</span> <span class="n">BACKGROUND_0</span> <span class="o">|</span> <span class="n">BACKGROUND_1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>If you compile and run the above (filling in the GenerateGradient function), you should end up with this:</p>

<div align="center">
<img src="/images/post_images/2017-04-11/bg1.png" /><br />
</div>

<p>Which is almost exactly what we wanted to end up with when we started! All that’s left is to add some movement, and this is pretty easy to do:</p>

<h2 id="moving-things-around">Moving Things Around</h2>

<p>In truth, backgrounds don’t really move, your viewport moves over top of the background. This makes sense with 1 background, but it gets a bit abstract when you think about multiple backgrounds moving at once. In essence, all you have to keep in mind is that increasing the X value of the background scrolling register is going to move it to the left, because what you’re doing is actually moving where your screen is to the right. The same is true for the vertical scrolling register.</p>

<p>As you may have guessed from that explanation, each background on the GBA has two additional registers, one for X offset, and one for Y offset. All backgrounds will repeat infinitely as you scroll them, so you can keep incrementing these values at will, without worrying about resetting them when you get to the edge of a background image. These registers are defined as follows:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define REG_BG0_SCROLL_H       *((volatile uint16*)(0x04000010))
#define REG_BG0_SCROLL_V       *((volatile uint16*)(0x04000012))
#define REG_BG1_SCROLL_H       *((volatile uint16*)(0x04000014))
#define REG_BG1_SCROLL_V       *((volatile uint16*)(0x04000016))
#define REG_BG2_SCROLL_H       *((volatile uint16*)(0x04000018))
#define REG_BG2_SCROLL_V       *((volatile uint16*)(0x0400001A))
#define REG_BG2_SCROLL_H       *((volatile uint16*)(0x0400001C))
#define REG_BG2_SCROLL_V       *((volatile uint16*)(0x0400001E))</span></code></pre></div>

<p>These are pretty self explanatory, assign numbers to them to make the corresponding background move. The only weird part about them is that they are Write-Only, so you can’t simply increment the value in one of the registers, nor can you ever read the value in the register, you can just write to it.</p>

<p>Using these registers, it’s trivial to modify our code from earlier to make things scroll. For brevity’s sake, I’m just going to show how to modify the while(1){} section from the above code, rather than paste the whole thing again:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">hScroll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">h2Scroll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vsync</span><span class="p">();</span>

    <span class="n">REG_BG0_SCROLL_H</span> <span class="o">=</span> <span class="o">-</span><span class="n">hScroll</span><span class="p">;</span>
    <span class="n">REG_BG1_SCROLL_H</span> <span class="o">=</span> <span class="n">h2Scroll</span><span class="p">;</span>
    <span class="n">h2Scroll</span> <span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">hScroll</span> <span class="o">=</span> <span class="n">h2Scroll</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>This is pretty much what you’d expect, background 0 is being assigned a value that is decreasing, which means it should appear to be moving right on the screen (since our viewport is moving left), and vice versa with the gradient background. This matches up with the scroll directions we had at the top of the post. Which is perfect, because that means we’re done!</p>

<h2 id="conclusion">Conclusion</h2>

<p>I suppose I should link you to some tools that can be used to create backgrounds, but I do so only grudgingly, because I don’t think they’re great. Tonc suggests <a href="http://www.tilemap.co.uk/mappy.php">Mappy</a> and <a href="http://nessie.gbadev.org/">MapEd</a>. To be fair, I haven’t written a tile mapping tool so I don’t really have much of a leg to stand on when criticizing these, but I found them rather fiddly to use, which is why I ended up just hand building some really simple ones for this post.</p>

<p>I’d love to hear about better tools for doing this sort of work. I think <a href="http://www.mapeditor.org/">Tiled</a> might be better, but I don’t know how set up it is for GBA style stuff. In any case, I’d love to hear about what tools might be better <a href="https://twitter.com/khalladay">on Twitter</a>. See you next week!</p>

</div>

<div id="related">
  <h3>Recent Posts</h3>
  <ul class="posts">
    
    <li>
      <span>28 Mar 2018 &raquo;</span> <a href="/blog/tutorial/vulkan/2018/03/28/SSBO-VS-Uniform-Buffer-2.html">Re-Testing Vulkan Transform Data Handling Strategies</a>
    </li>
    
    <li>
      <span>27 Mar 2018 &raquo;</span> <a href="/blog/tutorial/vulkan/2018/03/27/SSBO-VS-Uniform-Buffer.html">Handling Transform Data in Vulkan</a>
    </li>
    
    <li>
      <span>05 Feb 2018 &raquo;</span> <a href="/blog/tutorial/vulkan/2018/02/05/Bind-Once-Uniform-Data-Vulkan.html">A "Bind Once" Approach to Uniform Data</a>
    </li>
    
    <li>
      <span>28 Jan 2018 &raquo;</span> <a href="/blog/tutorial/vulkan/2018/01/28/Textue-Arrays-Vulkan.html">Using Arrays of Textures in Vulkan Shaders</a>
    </li>
    
  </ul>
</div>


      <div class="footer">
        <div class="disclaimer">
  
  <p>
    The postings on this site are my own and don't necessarily represent my 
    employer’s positions, strategies or opinions.
  </p>
  

  <p>
    © Kyle Halladay, 2014 &mdash; built with <a href="http://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/swanson/lagom">Lagom theme</a>
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40292745-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
