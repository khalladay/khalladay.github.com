<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kyle Halladay - GBA By Example - Getting User Input</title>
  <meta name="author" content="Kyle Halladay" />
  <meta name="description" content="I build shaders, renderers, games, and other stuff that's fun to stare at." />
  <link rel="canonical" href="http://kylehalladay.com/blog/tutorial/gba/2017/04/18/GBA-By-Example-4.html" />
  <meta name="keywords" content="life,code,software,development,games,graphics,shaders,indie" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Kyle Halladay" href="http://kylehalladay.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.jpg" id="logo" alt="Blog logo" width="200" height="200"/>
  </a>
  <h2>I'm <a href="/">Kyle Halladay</a>.</h2>
  <div id="bio">
    <p>I do graphics and engine programming for games. </p>
    <p>I'm the author of <a href="https://www.amazon.com/Practical-Shader-Development-Fragment-Developers/dp/1484244567">Practical Shader Development</a>, which is all about learning to write shaders.
    <p>I also dabble in GBA dev, you can find my tutorials <a href="/gba.html">here.</a>
    <p>Check out <a href="/archive.html">some other stuff I've written</a></p>
  </div>
  <div id="social">
    Want to say hi?
<div id="stalker">
  
  <a title="khalladay on Github" href="https://github.com/khalladay">
    <i class="fa fa-github-square"></i>
  </a>
  

  

  

  

  

  
  <a title="khalladay on Twitter" href="https://twitter.com/khalladay">
    <i class="fa fa-twitter-square"></i>
  </a>
  

  

  

  
  <a title="Kyle Halladay on LinkedIn" href="https://www.linkedin.com/in/kylehalladay">
    <i class="fa fa-linkedin-square"></i>
  </a>
  

  

  
  <a title="Kyle Halladay via Email" href="mailto:k.mj.halladay@gmail.com">
    <i class="fa fa-envelope-square"></i>
  </a>
  

  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="fa fa-rss-square"></i>
  </a>
</div>

  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <topbar><div align="center"><h2><a href="/index.html" style="color:#000">KyleHalladay.com</a></h2></div>
      <div align="center" style="font-size:18px"><a href="/archive.html">Archive</a></div>
      <hr style="border-color:#000; margin:1em -0.25em;"></topbar>

      <p class="meta">

</p>

<h1 class="title">GBA By Example - Getting User Input</h1>

<div id="post">
  <p>(Note: This is Part 5 of my GBA by Example series. A list of my other GBA tutorials can be found <a href="http://kylehalladay.com/gba.html">here</a>)</p>

<p>We’ve covered an awful lot of drawing in these posts, but it takes a lot more than drawing code to make a game. One of the key parts of building something playable is letting users actually be able to interact with our code, so today I’m going to go over how to get user input on the GBA. It’s going to be short and sweet, because it’s really not that complicated on this platform, which is great, because it means that we can spend more time on building an example program this week.</p>

<p>By the end of the post today, we’re going to end up with a simple program that displays a sprite and changes the background based on what button was last pressed. It’s going to look something like this:</p>

<div align="center">
<img src="/images/post_images/2017-04-18/input.gif" />
<font size="2"> Initially this cleared the screen after each press so I could properly do the Konami code.<br />The gif was reeeaalllyy annoying though</font>
<br /><br />
</div>

<p>Let’s get started :)</p>

<h2 id="detecting-what-keys-are-pressed">Detecting What Keys Are Pressed</h2>

<p>I assume if you’re interested in these posts, you already know what a GBA looks like. Just in case, here’s a photo with all the inputs shows:</p>

<div align="center">
<img src="/images/post_images/2017-04-18/gba.jpg" />
<br />
</div>

<p>The GBA has 10 buttons that the user can press while a game is running:</p>

<ul>
  <li>A / B buttons</li>
  <li>Start / Select Buttons</li>
  <li>R / L Shoulder Buttons</li>
  <li>DPAD - (Left, Right, Up, Down)</li>
</ul>

<p>Each of these buttons can be in one of two states - down or up. Conveniently, the state of every button is stored in a single 16 bit value (with only the lower 10 bits used). This value is known as the <em>Input</em> Register. It, and the location of each key’s corresponding bit are as follows:</p>

<div align="center">
<table style="border:1px solid black; width=600px; padding:2px;">
<colgroup>
<col width="200px" />
<col width="400px" />
</colgroup>
<thead style="border:1px solid black; background-color:#FF8854;">
<tr class="header">
<th>REG_INPUT</th>
<th> 0x FEDC BA98 7654 3210</th>
</tr>
</thead>
<tbody>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td>FEDCBA</td>
<td style="border:1px solid black;">Ignored / Undefined Data</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">9</td>
<td>Left Shoulder Button </td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">8</td>
<td>Right Shoulder Button</td>
</tr>
<tr style="border:1px solid black;">
<td style="border:1px solid black;">7</td>
<td>DPAD -&gt; Down</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">6</td>
<td>DPAD -&gt; Up</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">5</td>
<td>DPAD -&gt; Left</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">4</td>
<td>DPAD -&gt; Right</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">3</td>
<td>Start Button</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">2</td>
<td>Select Button</td>
</tr>

<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">1</td>
<td>B Button</td>
</tr>
<tr style="border:1px solid black; background-color:#DDDDDD;">
<td style="border:1px solid black;">0</td>
<td>A Button</td>
</tr>
</tbody>
</table>
</div>
<p><br /></p>

<p>The only bit of weirdness with all of this is that the GBA represents keys which are in their Up (un-pressed) state with a value of 1, and keys that are pressed with a value of 0. This means that if we were to read the value of the input register while the Start button was pressed, we would expect to see a value of <strong>0x0000 0011 1111 0111</strong>, notice that the bit that corresponds to the start button is 0, because the button is down.</p>

<p>Turning the above table into a set of constants representing which bit is set for each key looks lkke this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define REG_KEYINPUT  (* (volatile uint16*) 0x4000130)
</span>
<span class="cp">#define KEY_A        0x0001
#define KEY_B        0x0002
#define KEY_SELECT   0x0004
#define KEY_START    0x0008
#define KEY_RIGHT    0x0010
#define KEY_LEFT     0x0020
#define KEY_UP       0x0040
#define KEY_DOWN     0x0080
#define KEY_R        0x0100
#define KEY_L        0x0200
</span>
<span class="cp">#define KEY_MASK     0xFC00</span></code></pre></div>

<p>and using the above table, a function that returns a non zero value if a key is down might look like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">uint32</span> <span class="nf">getKeyState</span><span class="p">(</span><span class="n">uint16</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">key_code</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REG_INPUT</span> <span class="o">|</span> <span class="n">KEY_MASK</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>Because we aren’t immediately inverting the value in the input register (like <a href="http://www.coranac.com/tonc/text/keys.htm">Tonc</a> does), the bitwise logic for this can be a bit unintuitive, so let’s walk through how the above function works.</p>

<p>For the example, let’s assume that we’re testing to see if the Start button is currently pressed:</p>

<ul>
  <li>First, We get the value from the REG_INPUT register, and OR it with a bit mask that makes sure the undefined bits in the value are set to 1 (called KEY_MASK above)</li>
</ul>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="nl">INPUT:</span>  <span class="o">????</span> <span class="o">??</span><span class="mi">11</span> <span class="mi">1111</span> <span class="mo">0111</span>
 <span class="n">FLAG</span> <span class="o">:</span> <span class="mi">1111</span> <span class="mi">1100</span> <span class="mo">0000</span> <span class="mo">0000</span>
 <span class="o">--------------------------</span>
        <span class="mi">1111</span> <span class="mi">1111</span> <span class="mi">1111</span> <span class="mo">0111</span></code></pre></div>

<ul>
  <li>Next we AND the value with the Start mask: 0x0008</li>
</ul>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="nl">INPUT:</span>  <span class="mi">1111</span> <span class="mi">1111</span> <span class="mi">1111</span> <span class="mo">0111</span>
 <span class="n">START</span><span class="o">:</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mi">1000</span>
 <span class="o">--------------------------</span>
<span class="n">val</span><span class="o">=</span> <span class="mi">0</span><span class="n">x</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span>
<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">);</span> <span class="o">//</span><span class="nb">true</span><span class="p">,</span> <span class="n">key</span> <span class="n">is</span> <span class="n">DOWN</span></code></pre></div>

<ul>
  <li>
    <p>This gives us 0, because of how the GBA stores key states (Remember, 1 is UP), so we just return whether our result == false so that we get a non zero value when the button is down</p>
  </li>
  <li>
    <p>If instead of the Start Mask, we checked a different button, like the A Button:</p>
  </li>
</ul>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="nl">INPUT:</span> <span class="mi">1111</span> <span class="mi">1111</span> <span class="mi">1111</span> <span class="mo">0111</span>
 <span class="n">A</span> <span class="n">BTN</span><span class="o">:</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0001</span>
 <span class="o">--------------------------</span>
<span class="n">val</span><span class="o">=</span> <span class="mi">0</span><span class="n">x</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0001</span>

<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">);</span> <span class="o">//</span><span class="nb">false</span><span class="p">,</span> <span class="n">key</span> <span class="n">is</span> <span class="n">UP</span></code></pre></div>

<p>The KEY_MASK constant is important for this function to work, because we have no idea that the top 6 bits of this value are being set to (whatever it is, it’s junk data), and we want to be sure that we’re only testing our key_code value against data that we expect is in the input register.</p>

<p>Always masking the KEY_INPUT register by the KEY_MASK value seems a bit excessive to me though. What I prefer to do (and what you’ll see elsewhere on line), is to use a function that will store the value in the input register in a 16 bit variable, and perform the masking then. This function is called once per frame, and then you don’t have to worry about OR-ing with KEY_MASK every time you want to read a value from the hardware:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">uint16</span> <span class="n">input_cur</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">key_poll</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">input_cur</span> <span class="o">=</span> <span class="n">REG_KEYINPUT</span> <span class="o">|</span> <span class="n">KEY_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint32</span> <span class="nf">getKeyState</span><span class="p">(</span><span class="n">uint16</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">input_cur</span> <span class="o">&amp;</span> <span class="n">key_code</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">key_poll</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">getKeyState</span><span class="p">(</span><span class="n">KEY_L</span><span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//key is down
</span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>This is great, but it only lets us test if the user is currently holding down a key, it doesn’t let us detect if the key has been just pressed. This is great for things like charging an attack, but not as good for something like triggering a jump, because it’s going to read as true for multiple frames unless your user has the reflexes of a cat.</p>

<h2 id="detecting-key-press-and-key-release">Detecting Key Press and Key Release</h2>

<p>The obvious next thing we need to do is to be able to detect if the user has just started pressing or releasing a button. To do this, we need to store a second input state variable, that holds the input of the previous frame. To determine if a key’s state is new, we just have to compare the current frame’s input register to the one from the previous frame. It makes sense to do this register-copying inside the function we use to store the current frame’s input:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">uint16</span> <span class="n">input_cur</span><span class="p">;</span>
<span class="n">uint16</span> <span class="n">input_prev</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">key_poll</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">input_prev</span> <span class="o">=</span> <span class="n">input_cur</span><span class="p">;</span>
    <span class="n">input_cur</span> <span class="o">=</span> <span class="n">REG_KEYINPUT</span> <span class="o">|</span> <span class="n">KEY_MASK</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Then all we need are two new functions to detect key press and release:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">uint16</span> <span class="nf">wasKeyPressed</span><span class="p">(</span><span class="n">uint16</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">input_cur</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">input_prev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">key_code</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint16</span> <span class="nf">wasKeyReleased</span><span class="p">(</span><span class="n">uint16</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">input_cur</span> <span class="o">&amp;</span> <span class="n">input_prev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">key_code</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>If you’re confused by the above, writing it out on paper really helps, but I’m going to skip walking through it here because it really only matters long enough to write the above functions.</p>

<p>When it’s all put together, your input handling code might look like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#ifndef INPUT_H
#define INPUT_H
</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">input_cur</span> <span class="o">=</span> <span class="mh">0x03FF</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">input_prev</span> <span class="o">=</span> <span class="mh">0x03FF</span><span class="p">;</span>

<span class="cp">#define REG_KEYINPUT  (* (volatile unsigned short*) 0x4000130)
</span>
<span class="cp">#define KEY_A        0x0001
#define KEY_B        0x0002
#define KEY_SELECT   0x0004
#define KEY_START    0x0008
#define KEY_RIGHT    0x0010
#define KEY_LEFT     0x0020
#define KEY_UP       0x0040
#define KEY_DOWN     0x0080
#define KEY_R        0x0100
#define KEY_L        0x0200
</span>
<span class="cp">#define KEY_MASK     0xFC00
</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">key_poll</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">input_prev</span> <span class="o">=</span> <span class="n">input_cur</span><span class="p">;</span>
    <span class="n">input_cur</span> <span class="o">=</span> <span class="n">REG_KEYINPUT</span> <span class="o">|</span> <span class="n">KEY_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">wasKeyPressed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">key_code</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">input_cur</span> <span class="o">&amp;</span> <span class="n">input_prev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">wasKeyReleased</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span>  <span class="p">(</span><span class="n">key_code</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">input_cur</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">input_prev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">getKeyState</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">key_code</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">input_cur</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span></code></pre></div>

<p>That’s literally all there is to input handling on the GBA! You can stop here if that’s all you’re after, but I took it a step further and built the program you saw at the start of the article. I’m going to walk through how to put that together below.</p>

<p>But for the remainder of this post, and all future posts, I’m going to put the input handling code above into <strong>input.h</strong></p>

<h2 id="sprite-and-bg-data">Sprite and BG Data</h2>

<p>All the sprites that I’m using for the example project can be found <a href="https://github.com/khalladay/GBAInput/tree/master/code">on github</a>. It isn’t super compact, but for such a simple program, that’s not really that important. If you want to follow along as I build this, grab the data from there. If you just want the final product, you can find the whole thing <a href="https://github.com/khalladay/GBAInput">on github here</a>.</p>

<p>The function to load the sprite data is as follows:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>      <span class="n">uint8</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span>     <span class="n">uint16</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">uint32</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">uint16</span> <span class="n">ScreenBlock</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">uint16</span> <span class="n">Tile</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="k">typedef</span> <span class="n">Tile</span> <span class="n">TileBlock</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="cp">#define MEM_PALETTE             ((uint16*)(0x05000200))
#define MEM_TILE                ((TileBlock*)0x6000000)
#define MEM_OAM            ((volatile ObjectAttributes *)0x07000000)
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ObjectAttributes</span> <span class="p">{</span>
    <span class="n">uint16</span> <span class="n">attr0</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">attr1</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">attr2</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">,</span> <span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span> <span class="n">ObjectAttributes</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">LoadTileData</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//each sprite is 32 tiles
</span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_PALETTE</span><span class="p">,</span> <span class="n">Pal</span><span class="p">,</span>  <span class="n">PalLen</span> <span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ATiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">32</span><span class="p">],</span> <span class="n">BTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">64</span><span class="p">],</span> <span class="n">SelectTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">96</span><span class="p">],</span> <span class="n">StartTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">128</span><span class="p">],</span> <span class="n">RIGHTTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">160</span><span class="p">],</span> <span class="n">LEFTTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">192</span><span class="p">],</span> <span class="n">UPTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">224</span><span class="p">],</span> <span class="n">DOWNTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">LTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">],</span> <span class="n">RTiles</span><span class="p">,</span> <span class="n">TileLen</span><span class="p">);</span>

    <span class="k">volatile</span> <span class="n">ObjectAttributes</span> <span class="o">*</span><span class="n">spriteAttribs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MEM_OAM</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr0</span> <span class="o">=</span> <span class="mh">0x602F</span><span class="p">;</span>
    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr1</span> <span class="o">=</span> <span class="mh">0xC04F</span><span class="p">;</span>
    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span></code></pre></div>

<p>I’m not going to walk through this, because we’ve already covered how to load and set up sprites in <a href="http://kylehalladay.com/blog/tutorial/2017/04/04/GBA-By-Example-2.html">a previous post</a></p>

<p>I’m also using a simple 1 colour background in the gif from earlier, which I just created procedurally like so:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define MEM_BG_PALETTE          ((uint16*)(0x05000000))
#define MEM_SCREENBLOCKS        ((ScreenBlock*)0x6000000)
#define REG_BG0_CONTROL        *((volatile uint32*)(0x04000008))
</span>
<span class="kt">void</span> <span class="nf">CreateBackground</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MEM_BG_PALETTE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">RGB15</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">uint8</span> <span class="n">tile</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tile</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_TILE</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tile</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

    <span class="n">uint16</span> <span class="n">screenBlock</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">screenBlock</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">MEM_SCREENBLOCKS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">screenBlock</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2048</span><span class="p">);</span>

    <span class="n">REG_BG0_CONTROL</span> <span class="o">=</span> <span class="mh">0x0180</span><span class="p">;</span>

<span class="p">}</span></code></pre></div>

<p>Again, I’m not going to talk too much about this, because I covered it <a href="http://kylehalladay.com/blog/tutorial/2017/04/11/GBA-By-Example-3.html">last week</a>.</p>

<p>Great! Now that that’s out of the way, let’s do something more interesting.</p>

<h2 id="drawing-sprites">Drawing Sprites</h2>

<p>The most obvious thing to do is to draw a different sprite depending on what button is currently pressed. This is pretty easy since we laid our sprites out sequentially in memory:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kr">inline</span> <span class="n">uint16</span> <span class="nf">RGB15</span><span class="p">(</span><span class="n">uint32</span> <span class="n">red</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">green</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">blue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">red</span> <span class="o">|</span> <span class="p">(</span><span class="n">green</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">blue</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">DrawSprite</span><span class="p">(</span><span class="n">uint16</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">uint16</span> <span class="n">keys</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">KEY_A</span><span class="p">,</span> <span class="n">KEY_B</span><span class="p">,</span> <span class="n">KEY_SELECT</span><span class="p">,</span>
                          <span class="n">KEY_START</span><span class="p">,</span> <span class="n">KEY_RIGHT</span><span class="p">,</span> <span class="n">KEY_LEFT</span><span class="p">,</span>
                          <span class="n">KEY_UP</span><span class="p">,</span> <span class="n">KEY_DOWN</span><span class="p">,</span> <span class="n">KEY_L</span><span class="p">,</span> <span class="n">KEY_R</span><span class="p">};</span>

    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">key_code</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">volatile</span> <span class="n">ObjectAttributes</span> <span class="o">*</span><span class="n">spriteAttribs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MEM_OAM</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr0</span> <span class="o">=</span> <span class="mh">0x602F</span><span class="p">;</span>
    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr1</span> <span class="o">=</span> <span class="mh">0xC04F</span><span class="p">;</span>
    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr2</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

<span class="p">}</span></code></pre></div>

<p>And then move the sprite off screen when we don’t want to draw any text at all:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">ClearSprite</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">volatile</span> <span class="n">ObjectAttributes</span> <span class="o">*</span><span class="n">spriteAttribs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MEM_OAM</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">spriteAttribs</span><span class="o">-&gt;</span><span class="n">attr0</span> <span class="o">=</span> <span class="mh">0x60AF</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h2 id="animating-palette-information">Animating Palette Information</h2>

<p>In addition to drawing a sprite, let’s animate our background. You’ll notice that the background I created earlier was just a single colour. Since the colours live in palette memory, we can change the colour of the background just by changing the first colour in the background palette.</p>

<p>To make things simpler, I just added the code to change the background colour ot the DrawSprite function from above. There are certainly better / cleaner ways to do this, but for a quick and dirty example, I think the following will do.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">DrawSprite</span><span class="p">(</span><span class="n">uint16</span> <span class="n">key_code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">const</span> <span class="n">uint16</span> <span class="n">bgCols</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">RGB15</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">RGB15</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">RGB15</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span>
                            <span class="n">RGB15</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">RGB15</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span><span class="n">RGB15</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                            <span class="n">RGB15</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">16</span><span class="p">),</span><span class="n">RGB15</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">32</span><span class="p">),</span><span class="n">RGB15</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                            <span class="n">RGB15</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">32</span><span class="p">)};</span>
    <span class="n">MEM_BG_PALETTE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bgCols</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span></code></pre></div>

<p>Finally, I added a single line to the ClearSprite function:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">ClearSprite</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">MEM_BG_PALETTE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>You can do a lot of interesting things by modifying palettes directly, like having parts of sprites flash when hit, or having different enemies use the same sprite but use different colours (like the old Legend of Zelda games did with red / blue enemies). What I’ve done here is the simplest possible example of doing something like that, but it’s effective nonetheless.</p>

<h2 id="putting-it-all-together">Putting It All Together</h2>

<p>If you’re still with me, the hard part is over, and all that’s left is to write out the main function for our program, and make sure all the necessary #defines are there for things to work together.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">//previous code from article omitted for brevity
</span>
<span class="cp">#define VIDEOMODE_0    0x0000
#define ENABLE_OBJECTS 0x1000
#define MAPPINGMODE_1D 0x0040
#define BACKGROUND_0   0x0100
#define REG_DISPLAYCONTROL     *((volatile uint16*)(0x04000000))
#define REG_VCOUNT             *((volatile uint16*)(0x04000006))
</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vsync</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">REG_VCOUNT</span> <span class="o">&gt;=</span> <span class="mi">160</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">REG_VCOUNT</span> <span class="o">&lt;</span> <span class="mi">160</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">CreateBackground</span><span class="p">();</span>
    <span class="n">LoadTileData</span><span class="p">();</span>

    <span class="n">REG_DISPLAYCONTROL</span> <span class="o">=</span>  <span class="n">VIDEOMODE_0</span> <span class="o">|</span> <span class="n">ENABLE_OBJECTS</span> <span class="o">|</span> <span class="n">BACKGROUND_0</span> <span class="o">|</span> <span class="n">MAPPINGMODE_1D</span><span class="p">;</span>
    <span class="n">key_poll</span><span class="p">();</span>
    <span class="n">ClearSprite</span><span class="p">();</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vsync</span><span class="p">();</span>
        <span class="n">key_poll</span><span class="p">();</span>

        <span class="k">const</span> <span class="n">uint16</span> <span class="n">keys</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">KEY_A</span><span class="p">,</span> <span class="n">KEY_B</span><span class="p">,</span> <span class="n">KEY_SELECT</span><span class="p">,</span>
                                <span class="n">KEY_START</span><span class="p">,</span> <span class="n">KEY_RIGHT</span><span class="p">,</span> <span class="n">KEY_LEFT</span><span class="p">,</span>
                                <span class="n">KEY_UP</span><span class="p">,</span> <span class="n">KEY_DOWN</span><span class="p">,</span> <span class="n">KEY_L</span><span class="p">,</span> <span class="n">KEY_R</span><span class="p">};</span>
        <span class="n">ClearSprite</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">getKeyState</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">{</span>
                <span class="n">DrawSprite</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>If you want to grab a fully put-together, runnable version of the code, you can find it <a href="https://github.com/khalladay/GBAInput">here</a>, I’m going to omit it here because all the code is already available on this page, and I think a github repo is a far better delivery mechanism for that much code than pasting it here.</p>

<p>This has the disadvantage of only showing one key press at a time (and prioritizing some keys over others), but I’m ok with that, I just wanted a fun example program to show off input handling, and to provide more examples of how to use stuff we’ve done in articles past. I suppose modifying the above to show all the buttons that are currently pressed instead of one is left as an exercise to the reader?  ;)</p>

<h2 id="conclusion">Conclusion</h2>

<p>That’s it for this week! I’m kind of excited that we’ve covered enough ground that I can throw up some code and refer to previous articles instead of having to explain every line, but if that ended up being unclear today make sure to let me know via reddit or <a href="https://twitter.com/khalladay">twitter</a>, or wherever so I can adjust future articles.</p>

<p>Finally, As much fun as pumping these articles out every week is, I’m going to slow down a bit and do one every two weeks , so that I have more time for some other hobby projects. We’ve covered enough ground now that there’s no reason to wait around for me to post more before starting to build the GBA game of your dreams though, so get to it!</p>

<p>And as always, if you want to say hello, or ask questions, or point out mistakes I’ve made, I’m most easily reached <a href="https://twitter.com/khalladay">on Twitter</a>.</p>

</div>

<div id="related">
  <h3>Recent Posts</h3>
  <ul class="posts">
    
    <li>
      <span>04 Dec 2019 &raquo;</span> <a href="/blog/2019/12/04/Recreating-A-Dirty-Gamedev-Hack.html">Recreating An Old "Dirty Gamedev Trick"</a>
    </li>
    
    <li>
      <span>18 Apr 2019 &raquo;</span> <a href="/blog/2019/04/18/I-Wrote-A-Book.html">I Wrote A Book About Shaders!</a>
    </li>
    
    <li>
      <span>05 Feb 2018 &raquo;</span> <a href="/blog/tutorial/vulkan/2018/02/05/Bind-Once-Uniform-Data-Vulkan.html">A "Bind Once" Approach to Uniform Data</a>
    </li>
    
    <li>
      <span>28 Jan 2018 &raquo;</span> <a href="/blog/tutorial/vulkan/2018/01/28/Textue-Arrays-Vulkan.html">Using Arrays of Textures in Vulkan Shaders</a>
    </li>
    
  </ul>
</div>


      <div class="footer">
        <div class="disclaimer">
  
  <p>
    The postings on this site are my own and don't necessarily represent my 
    employer’s positions, strategies or opinions.
  </p>
  

  <p>
    © Kyle Halladay, 2014 &mdash; built with <a href="http://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/swanson/lagom">Lagom theme</a>
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40292745-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
