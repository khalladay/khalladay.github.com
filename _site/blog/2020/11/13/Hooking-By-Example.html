<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kyle Halladay - X64 Function Hooking by Example</title>
  <meta name="author" content="Kyle Halladay" />
  <meta name="description" content="I build shaders, renderers, games, and other stuff that's fun to stare at." />
  <link rel="canonical" href="http://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html" />
  <meta name="keywords" content="life,code,software,development,games,graphics,shaders,indie" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="Kyle Halladay" href="http://kylehalladay.com/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <a href="/">
    <img src="/logo.jpg" id="logo" alt="Blog logo" width="200" height="200"/>
  </a>
  <h2>I'm <a href="/">Kyle Halladay</a>.</h2>
  <div id="bio">
    <p>I do graphics and engine programming for games. </p>
    <p>I'm the author of <a href="https://www.amazon.com/Practical-Shader-Development-Fragment-Developers/dp/1484244567">Practical Shader Development</a>, which is all about learning to write shaders.</p>
    <p>Check out <a href="/archive.html">some other stuff I've written</a></p>
  </div>
  <div id="social">
    Want to say hi?
<div id="stalker">
  
  <a title="khalladay on Github" href="https://github.com/khalladay">
    <i class="fa fa-github-square"></i>
  </a>
  

  

  

  

  

  
  <a title="khalladay on Twitter" href="https://twitter.com/khalladay">
    <i class="fa fa-twitter-square"></i>
  </a>
  

  

  

  
  <a title="Kyle Halladay on LinkedIn" href="https://www.linkedin.com/in/kylehalladay">
    <i class="fa fa-linkedin-square"></i>
  </a>
  

  

  
  <a title="Kyle Halladay via Email" href="mailto:k.mj.halladay@gmail.com">
    <i class="fa fa-envelope-square"></i>
  </a>
  

  <a title="RSS feed" id="rss" href="/atom.xml">
    <i class="fa fa-rss-square"></i>
  </a>
</div>

  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <topbar><div align="center"><h2><a href="/index.html" style="color:#000">KyleHalladay.com</a></h2></div>
      <div align="center" style="font-size:18px"><a href="/archive.html">Archive</a></div>
      <hr style="border-color:#000; margin:1em -0.25em;"></topbar>

      <p class="meta">

</p>

<div style="font-size:14px">13 Nov 2020</div>
<h1 class="title">X64 Function Hooking by Example</h1> 

<div id="post">
  <style>
.collapsible {
  padding: 10px;
  background-color: #F0F0F0;
  border-style: solid;
  border-color: #333333;
  border-width: 1px;
}

.collapsewrapper2 {
    padding: 0px 0px 18px 0px;
}


</style>

<p>I’ve spent some time recently figuring out how function hooking works. There are tons of great resources available about it, but I’ve noticed that a lot of them are really light on providing example code, and the ones that do provide code tend to link to fully mature hooking frameworks. Usually the linked projects are really impressive, but they aren’t the easiest places to learn the basics from.</p>

<p>Now that I know enough to be dangerous, it seemed like fun to rectify this lack of sample code by building some hooking code from the ground up and walking through how to use that code to hook a running program. My past two blog posts were about making Notepad do weird stuff, so for the sake of variety, this post is going to pick on MSPaint instead.</p>

<p>I’m going to explain how to build 4 example programs. Two of them will show off fundamental hooking concepts by hooking functions in the example code itself. The other two will use those same concepts to hook MSPaint and make it disable the “Edit With Paint3D” button in a running MSPaint instance and force it to always draw with my favourite color (orange).</p>

<div align="center">
<img src="/images/post_images/2020-11-13/orangepaint.gif" />
<br /><br />
</div>

<p>If you’re only interested in sample code, I’ve published a github repo called <a href="https://github.com/khalladay/hooking-by-example">Hooking-by-Example</a> which has 14 increasingly complex example programs that demonstrate how function hooking works (or at least, the bits of it that I’ve figured out). Everything that I talk about here (and more) is also demonstrated by the programs in that repo.</p>

<h2 id="wtf-is-function-hooking">WTF is Function Hooking?</h2>
<p>Function Hooking is a programming technique that lets you to intercept and redirect function calls in a running application, allowing you to change that program’s runtime behaviour in ways that may not have been intended when the program was initially compiled. It’s a little bit like when a dog gets into a car thinking they’re going to the park and ends up at the vet instead. The dog called goToPark(), but instead unexpectedly ended up inside goToVet() instead. This example isn’t great.</p>

<p>The real fun of function hooking is that you can use it to change the behaviour of programs that you don’t have the source code to, or otherwise can’t recompile. Combined with process injection (which I explained a bit <a href="/blog/2020/05/20/Hooking-Input-Snake-In-Notepad.html">in my last post</a>), you can use function hooks to add entirely new behaviour to any program that you can run on your pc. For example, <a href="https://reshade.me/">ReShade</a> uses function hooking to add new postprocessing effects to games, and <a href="https://renderdoc.org/">RenderDoc</a> uses a form of hooking (although not the kind covered here) to allow you to debug graphics code in running applications.</p>

<p>More examples of things you might want to do with function hooking include:</p>

<ul>
  <li>Logging or replacing function arguments</li>
  <li>Disabling functions</li>
  <li>Measuing the execution time of a function</li>
  <li>Monitoring or replacing data before it gets sent over a network</li>
</ul>

<p>The only limits are your imagination and ability to read assembly!</p>

<h2 id="how-does-it-work">How Does It Work?</h2>
<p>Let’s say we have a function that adds two Gdiplus::ARGB values together, and we want to use a hook to bypass the addition logic and always return red. The ARGB type is a DWORD that uses a byte for Alpha, Red, Green, and Blue, respectively. Adding two of them together might look like this:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="nf">AddColors</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0xFF000000</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">));</span>
  <span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0x00FF0000</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0x00FF0000</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0x00FF0000</span><span class="p">));</span>
  <span class="kt">uint32_t</span> <span class="n">g</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0x0000FF00</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0x0000FF00</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0x0000FF00</span><span class="p">));</span>
  <span class="kt">uint32_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0x000000FF</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">a</span> <span class="o">|</span> <span class="n">r</span> <span class="o">|</span> <span class="n">g</span> <span class="o">|</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>The function that we want to replace it with (which I’ll call that “payload” function), looks like this:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="nf">ReturnRed</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mh">0xffff0000</span><span class="p">;</span>  
<span class="p">}</span></code></pre></div>

<p>If this was in your own code, you’d add a “return ReturnRed(left, right)” call to the beginning of AddColors(), recompile and call it a day, but what if you couldn’t recompile it? For example, what if it’s part of a closed source third party library, or the program that calls AddColors() is already running?</p>

<p>Rather than recompiling, we can use hooking to modify its instruction bytes instead, and replace the first instruction in AddColors() with a jmp to the beginning of the ReturnRed() function. This works even if the function we want to hook comes from a system dll, since DLL code segments are copy-on-write, so there’s no chance of a hook interfering with other processes.</p>

<p>Imagine that the first instruction in ReturnRed() is located 1024 bytes after AddColors() in memory. In assembly, replacing AddColors’ instructions with a jump will look like this:</p>

<div align="center">
<img src="/images/post_images/2020-11-13/basic_hook_thin.PNG" />
<br /><br />
</div>

<p>The jump instruction used here is a relative jump with a 32 bit operand. The opcode is E9, and that’s followed by a 4 byte value that represents how many bytes to jump.</p>

<p>Notice that after the jmp instruction, we’re left with garbage. This is because the process of overwriting the first 5 bytes of AddColors() left a partial instruction in its wake. The first byte of the second instruction was overwritten, but the rest of the bytes are still there, and who knows what instructions those map to. That leaves the rest of the function in an unknown (and likely invalid) state. This doesn’t matter for the example, because the program is going to jump to ReturnRed() before it ever gets to the garbage we just created, but it’s important to keep in mind.</p>

<p>We’ll write some hooks that preserve the hooked function’s original logic later in this post, so don’t worry about that too much right now. For our first example, we’ll build a program that destructively hooks a function, exactly like what’s shown in the diagram above (with some extra sauce to handle 64 bit code).</p>

<h2 id="example-1-our-first-function-hook">Example 1: Our First Function Hook</h2>
<p>Let’s roll with the example code already provided and write a program that actually redirects program flow from AddColors() to ReturnRed(). The game plan here is to end up with a main() function that looks like this:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">//both functions inside the same program as main()</span>
<span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="nf">AddColors</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">);</span>
<span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="nf">ReturnRed</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">//install a hook in AddColors, going to ReturnRed</span>
  <span class="n">InstallHook</span><span class="p">(</span><span class="n">AddColors</span><span class="p">,</span> <span class="n">ReturnRed</span><span class="p">);</span>

  <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">col</span> <span class="o">=</span>  <span class="n">AddColors</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x000000FF</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span> <span class="c1">//will always be 0xFFFF0000</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>In a 32 bit program, the logic for InstallHook() can be implemented pretty much exactly how the diagram above suggests it would be:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunction</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
  <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">AddColors</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>
    
  <span class="c1">//32 bit relative jump opcode is E9, takes 1 32 bit operand for jump offset</span>
  <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>
    
  <span class="c1">//to fill out the last 4 bytes of jmpInstruction, we need the offset between </span>
  <span class="c1">//the payload function and the instruction immediately AFTER the jmp instruction</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">payloadFunction</span> <span class="o">-</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

  <span class="c1">//install the hook</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>

<p>Things are a bit trickier in 64 bit, because functions can be located so far away from each other in memory that a 32 bit jmp instruction can’t jump that far, meaning that the 5 byte jump written by InstallHook() might be unable to reach the payload function from the hooked function.</p>

<p>There’s no such thing as a 64 bit relative jmp instruction, so the next best option is to jmp to an address stored in a register, like the assembly shown below. Note that this snippet uses the r10 register because it’s one of the few volatile registers that isn’t used for passing function arguments in the Windows x64 calling convention (<a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019">msdn link</a>)</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm">49 BA 00 00 00 00 00 00 04 00   mov        r10,400h  
41 FF E2                        jmp        r10</code></pre></div>

<p>If we throw this in the beginning of hooked functions instead of the 5 byte jump from before, we’d limit the number of functions that we could hook to those with 13 or more bytes. That’s a singificantly bigger limitation than our 32 bit code, so we’re instead going to write the bytes for this absolute jump somewhere in memory that’s close to the function we’re hooking. Then we’ll have the 5 byte jump we install in that function jump to this absolute jump, instead of straight to the payload function. <a href="https://github.com/TsudaKageyu/minhook">Minhook</a> refers to this absolute jump as the “relay function,” and I’m going to use that terminology as well.</p>

<div align="center">
<img src="/images/post_images/2020-11-13/64bit_basic_hook.PNG" />
<br /><br />
</div>

<p>Writing code to do this little dance is similar to the InstallHook() function shown above, but with a few more steps. The trickiest part of the process is allocating memory for the relay function that’s close enough to the target function to be reachable by a 5 byte jump. I’ve implemented logic for this in a function called AllocatePageNearAddress(). This function is a bit long, so I’ve included it’s implementation in the (expandable) box below, and omitted it from the sample code snippet immediately after that.</p>

<div class="collapsewrapper2">
<details class="collapsible">
    <summary>AllocPageNearAddress() implementation (click to expand)</summary>

    <div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span><span class="o">*</span> <span class="nf">AllocatePageNearAddress</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">targetAddr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SYSTEM_INFO</span> <span class="n">sysInfo</span><span class="p">;</span>
  <span class="n">GetSystemInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysInfo</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="n">sysInfo</span><span class="p">.</span><span class="n">dwPageSize</span><span class="p">;</span>

  <span class="kt">uint64_t</span> <span class="n">startAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">targetAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">//round down to nearest page boundary</span>
  <span class="kt">uint64_t</span> <span class="n">minAddr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMinimumApplicationAddress</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">maxAddr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">+</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMaximumApplicationAddress</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">startPage</span> <span class="o">=</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

  <span class="kt">uint64_t</span> <span class="n">pageOffset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="n">pageOffset</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">highAddr</span> <span class="o">=</span> <span class="n">startPage</span> <span class="o">+</span> <span class="n">byteOffset</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">lowAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">startPage</span> <span class="o">&gt;</span> <span class="n">byteOffset</span><span class="p">)</span> <span class="o">?</span> <span class="n">startPage</span> <span class="o">-</span> <span class="n">byteOffset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">needsExit</span> <span class="o">=</span> <span class="n">highAddr</span> <span class="o">&gt;</span> <span class="n">maxAddr</span> <span class="o">&amp;&amp;</span> <span class="n">lowAddr</span> <span class="o">&lt;</span> <span class="n">minAddr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">highAddr</span> <span class="o">&lt;</span> <span class="n">maxAddr</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">highAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lowAddr</span> <span class="o">&gt;</span> <span class="n">minAddr</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">lowAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pageOffset</span><span class="o">++</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">needsExit</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

  </details></div>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">WriteAbsoluteJump64</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">absJumpMemory</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addrToJumpTo</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">absJumpInstructions</span><span class="p">[]</span> <span class="o">=</span> 
  <span class="p">{</span> 
    <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="c1">//mov r10, addr</span>
    <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xE2</span> <span class="c1">//jmp r10</span>
  <span class="p">};</span> 

  <span class="kt">uint64_t</span> <span class="n">addrToJumpTo64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">addrToJumpTo</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">absJumpInstructions</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrToJumpTo64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrToJumpTo64</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">absJumpMemory</span><span class="p">,</span> <span class="n">absJumpInstructions</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">absJumpInstructions</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunction</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">relayFuncMemory</span> <span class="o">=</span> <span class="n">AllocatePageNearAddress</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>
    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">relayFuncMemory</span><span class="p">,</span> <span class="n">payloadFunction</span><span class="p">);</span> <span class="c1">//write relay func instructions</span>

    <span class="c1">//now that the relay function is built, we need to install the E9 jump into the target func,</span>
    <span class="c1">//this will jump to the relay function</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
    <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

    <span class="c1">//32 bit relative jump opcode is E9, takes 1 32 bit operand for jump offset</span>
    <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>

    <span class="c1">//to fill out the last 4 bytes of jmpInstruction, we need the offset between </span>
    <span class="c1">//the relay function and the instruction immediately AFTER the jmp instruction</span>
    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">relayFuncMemory</span> <span class="o">-</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="c1">//install the hook</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>

<p>With a bit of copy and paste magic, all the code snippets until now can be combined into our first example program. The end result is a small program that ends up calling ReturnRed() whenever we try to call AddColors(). The full code for this example is included in the expandable box below. Note that since this example creates x64 specific instructions for the relay function, it won’t work if it’s built as a 32 bit application. This will be the same for every example we build in this post.</p>

<div class="collapsewrapper2">
<details class="collapsible">
    <summary>Full Code For Example 1 (click to expand)</summary>

    <div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;Windows.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;memoryapi.h&gt;
</span>
<span class="cp">#include &lt;gdiplus.h&gt;
#pragma comment (lib, "Gdiplus.lib")
</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="nf">AddColors</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0xFF000000</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0xFF000000</span><span class="p">));</span>
    <span class="kt">uint32_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0x00FF0000</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0x00FF0000</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0x00FF0000</span><span class="p">));</span>
    <span class="kt">uint32_t</span> <span class="n">g</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0x0000FF00</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0x0000FF00</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0x0000FF00</span><span class="p">));</span>
    <span class="kt">uint32_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mh">0x000000FF</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">|</span> <span class="n">r</span> <span class="o">|</span> <span class="n">g</span> <span class="o">|</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="nf">ReturnRed</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mh">0xffff0000</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">AllocatePageNearAddress</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">targetAddr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SYSTEM_INFO</span> <span class="n">sysInfo</span><span class="p">;</span>
    <span class="n">GetSystemInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysInfo</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="n">sysInfo</span><span class="p">.</span><span class="n">dwPageSize</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">startAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">targetAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">//round down to nearest page boundary</span>
    <span class="kt">uint64_t</span> <span class="n">minAddr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMinimumApplicationAddress</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">maxAddr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">+</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMaximumApplicationAddress</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">startPage</span> <span class="o">=</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

    <span class="kt">uint64_t</span> <span class="n">pageOffset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="n">pageOffset</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">highAddr</span> <span class="o">=</span> <span class="n">startPage</span> <span class="o">+</span> <span class="n">byteOffset</span><span class="p">;</span>
		    <span class="kt">uint64_t</span> <span class="n">lowAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">startPage</span> <span class="o">&gt;</span> <span class="n">byteOffset</span><span class="p">)</span> <span class="o">?</span> <span class="n">startPage</span> <span class="o">-</span> <span class="n">byteOffset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">needsExit</span> <span class="o">=</span> <span class="n">highAddr</span> <span class="o">&gt;</span> <span class="n">maxAddr</span> <span class="o">&amp;&amp;</span> <span class="n">lowAddr</span> <span class="o">&lt;</span> <span class="n">minAddr</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">highAddr</span> <span class="o">&lt;</span> <span class="n">maxAddr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">highAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lowAddr</span> <span class="o">&gt;</span> <span class="n">minAddr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">lowAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pageOffset</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">needsExit</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WriteAbsoluteJump64</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">absJumpMemory</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addrToJumpTo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">absJumpInstructions</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span>
      <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="c1">//mov r10, addr</span>
      <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xE2</span> <span class="c1">//jmp r10</span>
    <span class="p">};</span>

    <span class="kt">uint64_t</span> <span class="n">addrToJumpTo64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">addrToJumpTo</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">absJumpInstructions</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrToJumpTo64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrToJumpTo64</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">absJumpMemory</span><span class="p">,</span> <span class="n">absJumpInstructions</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">absJumpInstructions</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunction</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">relayFuncMemory</span> <span class="o">=</span> <span class="n">AllocatePageNearAddress</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>
    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">relayFuncMemory</span><span class="p">,</span> <span class="n">payloadFunction</span><span class="p">);</span> <span class="c1">//write relay func instructions</span>

    <span class="c1">//now that the relay function is built, we need to install the E9 jump into the target func,</span>
    <span class="c1">//this will jump to the relay function</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
    <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

    <span class="c1">//32 bit relative jump opcode is E9, takes 1 32 bit operand for jump offset</span>
    <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>

    <span class="c1">//to fill out the last 4 bytes of jmpInstruction, we need the offset between </span>
    <span class="c1">//the relay function and the instruction immediately AFTER the jmp instruction</span>
    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">relayFuncMemory</span> <span class="o">-</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="c1">//install the hook</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">InstallHook</span><span class="p">(</span><span class="n">AddColors</span><span class="p">,</span> <span class="n">ReturnRed</span><span class="p">);</span>
    <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">col</span> <span class="o">=</span> <span class="n">AddColors</span><span class="p">(</span><span class="mh">0xFF000000</span><span class="p">,</span> <span class="mh">0x000000FF</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

  </details></div>

<p>This is all we need to know to start installing hooks in programs we have source access to, but there’s an annoying gap between that and being able to hook a running instance of a program. We’ll bridge that gap with the next example.</p>

<h2 id="example-2-hooking-functions-in-a-running-program">Example 2: Hooking Functions in a Running Program</h2>
<p>The second example program we’re going to build will disable the “Edit With Paint3D” button in a running instance of mspaint.exe.</p>

<p>There are 2 new hurdles we have to overcome in order to install a hook in a running program: getting the target program to execute our hooking logic, and figuring out the address of the function we want to hook. We’ll tackle these in order.</p>

<div align="center">
<img src="/images/post_images/2020-11-13/nopaint3d.gif" />
Our mission is to keep the Paint3D button from accomplishing its mission.
<br /><br />
</div>

<h3 id="getting-code-into-a-running-process">Getting Code Into a Running Process</h3>
<p>The simplest way to get an arbitrary process to execute hooking logic is to build that logic into a DLL and use DLL injection to get that code into the target process’ memory.</p>

<p>The nuts and bolts of how DLL injection work are beyond the scope of this blog post, but if you want to learn more, check out <a href="http://deniable.org/windows/inject-all-the-things">this article</a>. I’ve included the code for a basic DLL injection program in the collapsable box below. This is the code that the example program will use to inject its dll into mspaint.exe.</p>

<div class="collapsewrapper2">
<details class="collapsible">
    <summary>Full DLL Injection Code (click to expand)</summary>

    <div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">//Injector_LoadLibrary is a dll injector that uses LoadLibraryA to inject a dll into a running process</span>
<span class="c1">// usage: Injector_LoadLibrary &lt;process name&gt; &lt;path to dll&gt; </span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt; //for PROCESSENTRY32, needs to be included after windows.h
</span>
<span class="kt">void</span> <span class="nf">printHelp</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Injector_LoadLibrary</span><span class="se">\n</span><span class="s">Usage: Injector_LoadLibrary &lt;process name&gt; &lt;path to dll&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">createRemoteThread</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">processID</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">dllPath</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span>
    <span class="n">PROCESS_QUERY_INFORMATION</span> <span class="o">|</span> <span class="c1">//Needed to get a process' token</span>
    <span class="n">PROCESS_CREATE_THREAD</span> <span class="o">|</span>    <span class="c1">//for obvious reasons</span>
    <span class="n">PROCESS_VM_OPERATION</span> <span class="o">|</span>    <span class="c1">//required to perform operations on address space of process (like WriteProcessMemory)</span>
    <span class="n">PROCESS_VM_WRITE</span><span class="p">,</span>  <span class="c1">//required for WriteProcessMemory</span>
    <span class="n">FALSE</span><span class="p">,</span>      <span class="c1">//don't inherit handle</span>
    <span class="n">processID</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not open process with pid: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//once the process is open, we need to write the name of our dll to that process' memory</span>
  <span class="kt">size_t</span> <span class="n">dllPathLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dllPath</span><span class="p">);</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">dllPathRemote</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span>
    <span class="n">handle</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//let the system decide where to allocate the memory</span>
    <span class="n">dllPathLen</span><span class="p">,</span>
    <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="c1">//actually commit the virtual memory</span>
    <span class="n">PAGE_READWRITE</span><span class="p">);</span> <span class="c1">//mem access for committed page</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dllPathRemote</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not allocate %zd bytes in process with pid: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dllPathLen</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">BOOL</span> <span class="n">writeSucceeded</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span><span class="p">(</span>
    <span class="n">handle</span><span class="p">,</span>
    <span class="n">dllPathRemote</span><span class="p">,</span>
    <span class="n">dllPath</span><span class="p">,</span>
    <span class="n">dllPathLen</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writeSucceeded</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not write %zd bytes to process with pid %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dllPathLen</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//now get address of LoadLibraryW function inside Kernel32.dll</span>
  <span class="c1">//TEXT macro "Identifies a string as Unicode when UNICODE is defined by a preprocessor directive during compilation. Otherwise, ANSI string"</span>
  <span class="n">PTHREAD_START_ROUTINE</span> <span class="n">loadLibraryFunc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Kernel32.dll"</span><span class="p">)),</span> <span class="s">"LoadLibraryA"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">loadLibraryFunc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not find LoadLibraryA function inside kernel32.dll</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//now create a thread in remote process that loads our target dll using LoadLibraryA</span>

  <span class="n">HANDLE</span> <span class="n">remoteThread</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span>
    <span class="n">handle</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//default thread security</span>
    <span class="mi">0</span><span class="p">,</span> <span class="c1">//stack size for thread</span>
    <span class="n">loadLibraryFunc</span><span class="p">,</span> <span class="c1">//pointer to start of thread function (for us, LoadLibraryA)</span>
    <span class="n">dllPathRemote</span><span class="p">,</span> <span class="c1">//pointer to variable being passed to thread function</span>
    <span class="mi">0</span><span class="p">,</span> <span class="c1">//0 means the thread runs immediately after creation</span>
    <span class="nb">NULL</span><span class="p">);</span> <span class="c1">//we don't care about getting back the thread identifier</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">remoteThread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not create remote thread.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"Success! remote thread started in process %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Wait for the remote thread to terminate</span>
  <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">remoteThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

  <span class="c1">//once we're done, free the memory we allocated in the remote process for the dllPathname, and shut down</span>
  <span class="n">VirtualFreeEx</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dllPathRemote</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>
  <span class="n">CloseHandle</span><span class="p">(</span><span class="n">remoteThread</span><span class="p">);</span>
  <span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="nf">findPidByName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">HANDLE</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">PROCESSENTRY32</span> <span class="n">singleProcess</span><span class="p">;</span>
  <span class="n">h</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span> <span class="c1">//takes a snapshot of specified processes</span>
    <span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="c1">//get all processes</span>
    <span class="mi">0</span><span class="p">);</span> <span class="c1">//ignored for SNAPPROCESS</span>

  <span class="n">singleProcess</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

  <span class="k">do</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">singleProcess</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">singleProcess</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"PID Found: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
      <span class="n">CloseHandle</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32Next</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">singleProcess</span><span class="p">));</span>

  <span class="n">CloseHandle</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printHelp</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">createRemoteThread</span><span class="p">(</span><span class="n">findPidByName</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

  </details></div>

<p>The code for the dll we’re going to inject is basically identical to the last example except that main() will be replaced by DllMain(), and we need to do some extra work to get a pointer to the function we want to hook. With those concerns in mind, the skeleton of Example 2’s dll looks like this:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">//source for a hooking dll that will be injected into mspaint.exe</span>

<span class="cp">#include &lt;Windows.h&gt;
#include &lt;stdint.h&gt;
#include &lt;Psapi.h&gt;
</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">AllocatePageNearAddress</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">targetAddr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//same as before</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WriteAbsoluteJump64</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">absJumpMemory</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addrToJumpTo</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//same as before</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunction</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//same as before</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpvReserved</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ul_reason_for_call</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">InstallHook</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span> <span class="c1">//we'll fill this in later</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h3 id="what-function-do-we-need-to-hook">What Function Do We Need to Hook?</h3>
<p>Since our goal is to disable the “Edit With Paint3D” button, we need to find the mspaint.exe function that handles that button press. We know that the “Edit With Paint3D” button eventually launches a Paint3D process, so we can be reasonably sure that a function like CreateProcessA() or OpenProcess() gets called at some point during the button handling function. Blindly hooking either of these functions and redirecting them to an empty function doesn’t work (I tried), but throwing some breakpoints on them is as good a place to start as any.</p>

<p>If we look at the functions imported by mspaint in a debugger (like <a href="https://x64dbg.com">x64dbg</a>), we can see that it is in fact importing OpenProcess(), so our first step is to throw a breakpoint there and then see what happens when we press the paint3d button.</p>

<div align="center">
<img src="/images/post_images/2020-11-13/reverse_step1.PNG" />
<br /><br />
</div>

<p>It turns out that our breakpoint <em>does</em> get hit in response to the button click, which is fantastic. If we switch over to the callstack view while we’re stopped at the breakpoint, we can see a couple of mspaint.exe functions much higher up in the stack. It’s possible that the one of these that’s highest in the callstack is the button handler function we’re after.</p>

<div align="center">
<img src="/images/post_images/2020-11-13/reverse_step2.png" />
<br /><br />
</div>

<p>Going to the address shown for that function brings us into middle of a function body. What we’re after is the relative virtual address (RVA) of the beginning of this function. x64dbg makes this really easy. All we need to do is scroll up until we find the first instruction for the function, then right click on the address of that instruction and select “Copy-&gt;RVA.” In my version of mspaint.exe, the RVA of this function is 0x4AA40.</p>

<p>I’m going to save us some trial and error here and reveal that 0x4AA40 ends up <em>not</em> being the address we need. The real button handler runs on a different thread. Hooking 0x4AA40 and redirecting it to an empty function disables the Paint3D button, but only if the current document is empty.</p>

<p>I wish I had a better procedure to share, but my next step after realizing the above was to retry the same procedure except draw something in paint before I clicked the Paint3D button. The callstack I got then had a number of calls inside uiribbon.dll, and the highest mspaint.exe function in that stack ended up being the button handler. Its RVA was 0x6C6F0.</p>

<h3 id="turning-an-rva-into-a-runtime-memory-address">Turning an RVA Into a Runtime Memory Address</h3>
<p>RVAs are addresses which are relative to the base address of the module they’re located in. Since programs (and individual modules, thanks to ASLR) can be loaded into memory at different locations across multiple runs of the same program, having the RVA of a function means that we can reliably get that function’s address, no matter where the process is loaded in memory.</p>

<p>In this case, our target function is implemented inside the base module of the process (since it isn’t imported from a dll), so we need to find the base address of the mspaint.exe module. We can do this with the function below.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint64_t</span> <span class="nf">GetBaseModuleForProcess</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">HANDLE</span> <span class="n">process</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
  <span class="n">HMODULE</span> <span class="n">processModules</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="n">DWORD</span> <span class="n">numBytesWrittenInModuleArray</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">EnumProcessModules</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">processModules</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMODULE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numBytesWrittenInModuleArray</span><span class="p">);</span>

  <span class="n">DWORD</span> <span class="n">numRemoteModules</span> <span class="o">=</span> <span class="n">numBytesWrittenInModuleArray</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMODULE</span><span class="p">);</span>
  <span class="n">CHAR</span> <span class="n">processName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">GetModuleFileNameEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">processName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span> <span class="c1">//a null module handle gets the process name</span>
  <span class="n">_strlwr_s</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

  <span class="n">HMODULE</span> <span class="n">module</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//An HMODULE is the DLL's base address </span>

  <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numRemoteModules</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">CHAR</span> <span class="n">moduleName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">CHAR</span> <span class="n">absoluteModuleName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">GetModuleFileNameEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">processModules</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">moduleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="n">_fullpath</span><span class="p">(</span><span class="n">absoluteModuleName</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
    <span class="n">_strlwr_s</span><span class="p">(</span><span class="n">absoluteModuleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="n">absoluteModuleName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">module</span> <span class="o">=</span> <span class="n">processModules</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">module</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>HMODULES are actually pointers to the location of a module in memory, so the cast to a uint64_t in the above example is mostly for convenience. In order to get the address of our target function, we’ll need to add the function’s RVA to this base module address.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="nf">GetFunc2HookAddr</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">functionRVA</span> <span class="o">=</span> <span class="mh">0x6C6F0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">func2HookAddr</span> <span class="o">=</span> <span class="n">GetBaseModuleForProcess</span><span class="p">()</span> <span class="o">+</span> <span class="n">functionRVA</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">func2HookAddr</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>If we were hooking a function that was imported from a dll, we’d need to modify the GetBaseMdouleForProcess() function to let us specify the name of the module that we were after, rather than being hardcoded to find the base. We’ll do this in the fourth example in this post, but you can also see an example of this in the code for my hooking-by-example repo <a href="https://github.com/khalladay/hooking-by-example/blob/64d6eb01bcb253d0f622e5fbae434d344ccf8330/hooking-by-example/hooking_common.h#L182">here</a>.</p>

<h3 id="putting-it-all-together">Putting It All Together</h3>
<p>Now that we have a function to hook, we need to do is to redirect it to an empty payload function to disable it. This is straightforward as it sounds:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">NullPaint3DButtonHandler</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpvReserved</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ul_reason_for_call</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">InstallHook</span><span class="p">(</span><span class="n">GetFunc2HookAddr</span><span class="p">(),</span> <span class="n">NullPaint3DButtonHandler</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>We got a bit lucky here because the button handling function doesn’t have a significant return value (or at least, returning 0 from it is valid). The smart way to approach this would probably be to spend some time in the debugger really understanding what this button handling function does, so that we could write a payload that we knew wasn’t going to break anything, but sometimes it’s better to be lucky than smart.</p>

<p>All we need to do to finish things off is add the implementation for GetFunc2HookAddr() and the payload function into our example dll. The end result is a dll that disables the “Edit with Paint3D” button when injected into mspaint, exactly as we planned. The full source for this example is in the collapsable bow below.</p>

<div class="collapsewrapper2">
<details class="collapsible">
    <summary>Full Code for Example 2 (click to expand)</summary>

    <div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;Windows.h&gt;
#include &lt;stdint.h&gt;
#include &lt;Psapi.h&gt;
</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">AllocatePageNearAddress</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">targetAddr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SYSTEM_INFO</span> <span class="n">sysInfo</span><span class="p">;</span>
  <span class="n">GetSystemInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysInfo</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="n">sysInfo</span><span class="p">.</span><span class="n">dwPageSize</span><span class="p">;</span>

  <span class="kt">uint64_t</span> <span class="n">startAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">targetAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">//round down to nearest page boundary</span>
  <span class="kt">uint64_t</span> <span class="n">minAddr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMinimumApplicationAddress</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">maxAddr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">+</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMaximumApplicationAddress</span><span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">startPage</span> <span class="o">=</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

  <span class="kt">uint64_t</span> <span class="n">pageOffset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="n">pageOffset</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">highAddr</span> <span class="o">=</span> <span class="n">startPage</span> <span class="o">+</span> <span class="n">byteOffset</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">lowAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">startPage</span> <span class="o">&gt;</span> <span class="n">byteOffset</span><span class="p">)</span> <span class="o">?</span> <span class="n">startPage</span> <span class="o">-</span> <span class="n">byteOffset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">needsExit</span> <span class="o">=</span> <span class="n">highAddr</span> <span class="o">&gt;</span> <span class="n">maxAddr</span> <span class="o">&amp;&amp;</span> <span class="n">lowAddr</span> <span class="o">&lt;</span> <span class="n">minAddr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">highAddr</span> <span class="o">&lt;</span> <span class="n">maxAddr</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">highAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lowAddr</span> <span class="o">&gt;</span> <span class="n">minAddr</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">lowAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pageOffset</span><span class="o">++</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">needsExit</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">uint64_t</span> <span class="nf">GetBaseModuleForProcess</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">HANDLE</span> <span class="n">process</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
  <span class="n">HMODULE</span> <span class="n">processModules</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="n">DWORD</span> <span class="n">numBytesWrittenInModuleArray</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">EnumProcessModules</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">processModules</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMODULE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numBytesWrittenInModuleArray</span><span class="p">);</span>

  <span class="n">DWORD</span> <span class="n">numRemoteModules</span> <span class="o">=</span> <span class="n">numBytesWrittenInModuleArray</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMODULE</span><span class="p">);</span>
  <span class="n">CHAR</span> <span class="n">processName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">GetModuleFileNameEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">processName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span> <span class="c1">//a null module handle gets the process name</span>
  <span class="n">_strlwr_s</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

  <span class="n">HMODULE</span> <span class="n">module</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//An HMODULE is the DLL's base address </span>

  <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numRemoteModules</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">CHAR</span> <span class="n">moduleName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">CHAR</span> <span class="n">absoluteModuleName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">GetModuleFileNameEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">processModules</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">moduleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="n">_fullpath</span><span class="p">(</span><span class="n">absoluteModuleName</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
    <span class="n">_strlwr_s</span><span class="p">(</span><span class="n">absoluteModuleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="n">absoluteModuleName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">module</span> <span class="o">=</span> <span class="n">processModules</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">module</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WriteAbsoluteJump64</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">absJumpMemory</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addrToJumpTo</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">absJumpInstructions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
            <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xE2</span> <span class="p">};</span>

  <span class="kt">uint64_t</span> <span class="n">addrToJumpTo64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">addrToJumpTo</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">absJumpInstructions</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrToJumpTo64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrToJumpTo64</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">absJumpMemory</span><span class="p">,</span> <span class="n">absJumpInstructions</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">absJumpInstructions</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">targetFunction</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunction</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">functionRVA</span> <span class="o">=</span> <span class="mh">0x6C6F0</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">func2HookAddr</span> <span class="o">=</span> <span class="n">GetBaseModuleForProcess</span><span class="p">()</span> <span class="o">+</span> <span class="n">functionRVA</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">func2HookAddr</span><span class="p">;</span>

  <span class="kt">void</span><span class="o">*</span> <span class="n">relayFuncMemory</span> <span class="o">=</span> <span class="n">AllocatePageNearAddress</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>
  <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">relayFuncMemory</span><span class="p">,</span> <span class="n">NullPaint3DButtonHandler</span><span class="p">);</span> <span class="c1">//write relay func instructions</span>

  <span class="c1">//now that the relay function is built, we need to install the E9 jump into the target func,</span>
  <span class="c1">//this will jump to the relay function</span>
  <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
  <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

  <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>

  <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">relayFuncMemory</span> <span class="o">-</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

  <span class="c1">//install the hook</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">GetFunc2HookAddr</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">functionRVA</span> <span class="o">=</span> <span class="mh">0x6C6F0</span><span class="p">;</span> 
  <span class="kt">uint64_t</span> <span class="n">func2HookAddr</span> <span class="o">=</span> <span class="n">GetBaseModuleForProcess</span><span class="p">()</span> <span class="o">+</span> <span class="n">functionRVA</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">func2HookAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">NullPaint3DButtonHandler</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpvReserved</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ul_reason_for_call</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">InstallHook</span><span class="p">(</span><span class="n">GetFunc2HookAddr</span><span class="p">(),</span> <span class="n">NullPaint3DButtonHandler</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

  </details></div>

<h2 id="function-hooking-for-big-kids">Function Hooking for Big Kids</h2>
<p>The previous examples <em>technically</em> hooked a couple functions, but did so at the cost of destroying their original functionality. This meant that we couldn’t do things like modify function arguments being passed to the original functions, or add logging while preserving the original logic of the hooked programs. Real function hooking doesn’t have to make this trade, and our next two examples won’t either.</p>

<p>So far, the hooks we’ve created have had 3 parts: the hooked function, the relay function, and the hook payload. Now we need to add another step in this process, called a trampoline. With this new step, our hook process looks like this:</p>

<div align="center">
<img src="/images/post_images/2020-11-13/trampoline2.PNG" />
<br /><br />
</div>

<p>Rather than simply replace the initial instructions in the hooked function, we’re going to use those instructions to build a trampoline that we can call from a payload function when we want to execute the original version of the hooked function. A hook payload that uses a trampoline might look like this:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span><span class="p">(</span><span class="o">*</span><span class="n">AddColorsTrampoline</span><span class="p">)(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">);</span>
<span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="nf">AddColorHookPayload</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">left</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//perform some new action</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hook executed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">//replace one of the arguments being used to call</span>
  <span class="c1">//the hooked function</span>
  <span class="k">return</span> <span class="n">AddColorsTrampoline</span><span class="p">(</span><span class="mh">0xFFFF0000</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>At a super high level, trampolines need to do two things:</p>

<ol>
  <li>Execute the instructions that were overwritten when the hook jmp was installed in the hooked function.</li>
  <li>Jump back to the body of the hooked function AFTER the installed jump instruction, so that the rest of the function can continue like normal.</li>
</ol>

<p>The first item on this list is really easy to get working for contrived cases, but really difficult to get right for real world use. Consider the following assembly (shown with the addresses of the instructions on the left):</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm">EasyCase:
00007FF7F2691FF0    48 89 4C 24 08       mov         qword ptr [rsp+8],rcx  
00007FF7F2691FF5    55                   push        rbp  
00007FF7F2691FF6    57                   push        rdi  
00007FF7F2691FF7    48 81 EC 08 01 00 00 sub         rsp,108h  
00007FF7F2691FFE    48 8D 6C 24 20       lea         rbp,[rsp+20h]  
        [Rest of function omitted]</code></pre></div>

<p>This is an example of the “easy” case for creating a trampoline. The first 5 bytes of the function belong to one instruction, and that instruction doesn’t rely on any rip-relative addressing. All we need to do to make a trampoline for this function is copy the first 5 bytes to a buffer before we overwrite them with our hook, and then add a jump to 00007FF6E3521FF5 immediately after it. In assembly, this might look like this:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm">Trampoline:
48 89 4C 24 08                  mov         qword ptr [rsp+8],rcx  
49 BA F5 1F 69 F2 F7 7F 00 00   mov         r10,7FF7F2691FF5h  
41 FF E2                        jmp         r10</code></pre></div>

<p>Functions that are harder to hook with a trampoline might have multiple instructions contained in their first 5 bytes, or use instructions with relative operands, like jumps or rip-relative addresses. The snippet below shows an example of a function that has some of these issues.</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm">HardCase:
00007FF72B1F1390     85 C9          test        ecx,ecx  
00007FF72B1F1392     74 26          je          TargetFunc+2Ah (07FF72B1F13BAh)  
00007FF72B1F1394     83 F9 01       cmp         ecx,1  
00007FF72B1F1397     74 0C          je          TargetFunc+15h (07FF72B1F13A5h)
        [Rest of function omitted]</code></pre></div>

<p>In order to build a trampoline for this function, we’re going to have to get our hands dirty. First of all, we’re going to need to steal the first 7 bytes of this function instead of the first 5, so that we can execute whole instructions in our trampoline. Second, we’re going to need to do something about the je at 00007FF72B1F1392h, since it won’t make sense to do a relative jump once we relocate the instruction.</p>

<p>The next section of this post is going to walk through how to write code that deals with these “hard” issues, but as a bit of a teaser, here’s what the trampoline for this will look like:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm">HardCase_Trampoline:
85 C9                              test   ecx,ecx  
74 10                              je     000001FA4B770021  ; rewritten jump
83 F9 01                           cmp    ecx,1  
49 BA 97 13 09 C0 F6 7F 00 00      mov    r10,   7FF6C0091397h  ; Jump to hooked function body
41 FF E2                           jmp    r10  
49 BA BA 13 09 C0 F6 7F 00 00      mov    r10,   7FF6C00913BAh  ; Absolute Instruction Table Starts Here
41 FF E2                           jmp    r10</code></pre></div>

<p>This trampoline can be thought of as being made up of three sections (like a “jump sandwich”, which I thought was very funny when I wrote this at 5 am). It starts with the stolen bytes from the hooked instruction, with the relative instructions rewritten to jump to a later part of the trampoline. The meat of the sandwich is an absolute jump that goes back to the body of the hooked function (to an address <em>after</em> the jmp we installed for the hook). Finally, the bottom of the trampoline are absolute jumps (or calls, if we had any) that go to the addresses that the relative jumps/calls in the stolen bytes actually want to go.</p>

<div align="center">
<img src="/images/post_images/2020-11-13/trampoline_anatomy.PNG" />
<br /><br />
</div>

<p>Other sources refer to the absolute instruction table as a jump table, but I’m giving it a fancy name because it’s not going to contain jump instructions exclusively.</p>

<h2 id="example-3-building-a-trampoline-for-code-we-can-recompile">Example 3: Building a Trampoline For Code We Can Recompile</h2>
<p>We just saw the rough skeleton of the trampoline we’re going to build, now it’s time to write the code to build it. Roughly speaking, our plan of attack looks like this:</p>

<ol>
  <li>“Steal” the first 5+ bytes (rounded up to the nearest whole instruction) of the function we want to hook.</li>
  <li>Fixup any rip-relative addressing (like lea rcx,[rip+0xbeef])</li>
  <li>For each relative jump or call instruction, calculate the address that it originally intended to reference, and add an absolute jmp/call to that address in the Absolute Instruction Table.</li>
  <li>Rewrite the relative instructions in the stolen bytes to jump to their corresponding entry in the Absolute Instruction Table.</li>
  <li>Write a jump back to the 6th byte of the hooked function immediately after the stolen instruction bytes, to continue executing the hooked function once the trampoline ends.</li>
</ol>

<p>These steps won’t be completed sequentially in our final program, but I’ve split them out into discrete steps to make explaining things easier.</p>

<p>For a bit of context, here’s what our final InstallHook() function is going to look like when we’re done. We’re going to be constructing a BuildTrampoline() function which will be given a pointer to some memory to write a trampoline into, and not much else. BuildTrampoline() is going to be called from a modified version of the InstallHook() function we had in our earlier example. Notice that BuildTrampoline() will also return the size, in bytes, of the trampoline that it creates.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunc</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">trampolinePtr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
  <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

  <span class="kt">void</span><span class="o">*</span> <span class="n">hookMemory</span> <span class="o">=</span> <span class="n">AllocatePageNearAddress</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">trampolineSize</span> <span class="o">=</span> <span class="n">BuildTrampoline</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">hookMemory</span><span class="p">);</span>
  <span class="o">*</span><span class="n">trampolinePtr</span> <span class="o">=</span> <span class="n">hookMemory</span><span class="p">;</span>

  <span class="c1">//create the relay function</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">relayFuncMemory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hookMemory</span> <span class="o">+</span> <span class="n">trampolineSize</span><span class="p">;</span>
  <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">relayFuncMemory</span><span class="p">,</span> <span class="n">payloadFunc</span><span class="p">);</span> <span class="c1">//write relay func instructions</span>

  <span class="c1">//install the hook</span>
  <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>
  <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">relayFuncMemory</span> <span class="o">-</span> <span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>

<p>The intended use case for the trampoline pointer is to allow payload functions to call trampolines like regular functions, as shown in the snippet below.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">TargetFuncTrampoline</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="p">)</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">HookPayload</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hook executed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">TargetFuncTrampoline</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>Notice that we’re going to build the trampoline in the same “near” memory that the relay function is currently being constructed in. That’s going to make dealing with the rip-relative addressing a lot easier when we get it to it.</p>

<h3 id="step-1-stealing-instruction-bytes">Step 1: Stealing Instruction Bytes</h3>
<p>In order for our trampoline to work at all, it needs to execute the instructions that are overwritten when we install our hook. To do this, we need to “steal” these instruction bytes from our target function before overwriting them. The verb “steal” is important here - we’re not only going to copy these instruction bytes, we’re also going to replace them with 1 byte NOPs in the target function. That way won’t wind up with any partial instructions when we install the hook jump.</p>

<p>To make sure we steal whole instructions, we need to use a disassembly library. The rest of this article is going to use the <a href="http://www.capstone-engine.org/">Capstone</a> library for all disassembly tasks. Any disassembler will do, but Capstone has some features that are going to make our life easier later on.</p>

<p>This snippet shos how to steal the instructions contained within the first 5 bytes of a target function using Capstone. The StealBytes() function returns a struct with some additional data about the stolen instructions which we’ll use later.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="nc">X64Instructions</span>
<span class="p">{</span>
  <span class="n">cs_insn</span><span class="o">*</span> <span class="n">instructions</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">numInstructions</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">numBytes</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">X64Instructions</span> <span class="nf">StealBytes</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Disassemble stolen bytes</span>
  <span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>
  <span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
  <span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_DETAIL</span><span class="p">,</span> <span class="n">CS_OPT_ON</span><span class="p">);</span> <span class="c1">// we need details enabled for relocating RIP relative instrs</span>

  <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">cs_insn</span><span class="o">*</span> <span class="n">disassembledInstructions</span><span class="p">;</span> <span class="c1">//allocated by cs_disasm, needs to be manually freed later</span>
  <span class="n">count</span> <span class="o">=</span> <span class="n">cs_disasm</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">function</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">function</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disassembledInstructions</span><span class="p">);</span>

  <span class="c1">//get the instructions covered by the first 5 bytes of the original function</span>
  <span class="kt">uint32_t</span> <span class="n">byteCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">stolenInstrCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">disassembledInstructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">byteCount</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
    <span class="n">stolenInstrCount</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">byteCount</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//replace instructions in target func wtih NOPs</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="n">byteCount</span><span class="p">);</span>

  <span class="n">cs_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">{</span> <span class="n">disassembledInstructions</span><span class="p">,</span> <span class="n">stolenInstrCount</span><span class="p">,</span> <span class="n">byteCount</span> <span class="p">};</span>
<span class="p">}</span></code></pre></div>

<p>We’ll call this function right at the start of BuildTrampoline(), so it’s about time we started writing that function too. I’ve found the most intuitive way to structure BuildTrampoline() is to create 3 pointers at the start, each pointing to the next available location in each of the three sections of our trampoline memory. Whenever we write to a location pointed to by one of these pointers, we’ll then increment the pointer by that many bytes, so each of them is always pointing to an available memory address.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">uint32_t</span> <span class="nf">BuildTrampoline</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dstMemForTrampoline</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">X64Instructions</span> <span class="n">stolenInstrs</span> <span class="o">=</span> <span class="n">StealBytes</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>

  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">stolenByteMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">dstMemForTrampoline</span><span class="p">;</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">jumpBackMem</span> <span class="o">=</span> <span class="n">stolenByteMem</span> <span class="o">+</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numBytes</span><span class="p">;</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span> <span class="o">=</span> <span class="n">jumpBackMem</span> <span class="o">+</span> <span class="mi">13</span><span class="p">;</span> <span class="c1">//13 is the size of the 64 bit mov/jmp instruction pair at jumpBackMem</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numInstructions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="c1">//perform any fixup logic to the stolen instructions here</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="n">stolenByteMem</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">//write jump back to hooked func</span>

  <span class="n">free</span><span class="p">(</span><span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">);</span>
  <span class="k">return</span> <span class="kt">uint32_t</span><span class="p">(</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">absTableMem</span> <span class="o">-</span> <span class="n">dstMemForTrampoline</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>If we only ever needed to hook “easy” functions (as defined earlier), we could skip down to the last step in our trampoline creation procedure now. There’s a lot more legroom required to support less-than-easy functions though.</p>

<h3 id="step-2-fixing-up-rip-relative-addressing">Step 2: Fixing up RIP-Relative Addressing</h3>
<p>One case where our naiive trampoline building function will fail is if any of the stolen instructions contain rip-relative addressing. In x64, there are a <em>lot</em> of instructions that do this, but the easiest example is a function that calls printf.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">PrintHaha</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Haha</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>On my machine, the generated assembly uses an lea instruction to load the string location before the call to printf. The assembly string generated by visual studio makes it look like the lea call is grabbing an absolute address, but the instruction bytes reveal that we’re actually computing the address of the “Haha\n” string by adding an offset to the current value of the instruction pointer.</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm">PrintHaha:
00007FFCB54211E0 48 8D 0D F9 1F 00 00   lea         rcx,[string "Haha\n" (07FFCB54231E0h)]  
00007FFCB54211E7 E9 24 FE FF FF         jmp         printf (07FFCB5421010h)</code></pre></div>

<p>If we steal the lea instruction verbatim, we’ll get garbage data when we executed the stolen instruction because our instruction pointer will be at a different address. In order to actually use instructions that have rip-relative addressing in our trampoline, we need to fix up the offsets they use to be relative to our trampoline memory.</p>

<p>The first step of this is to detect when an instruction contains a rip-relative operand. Capstone makes this easy.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cs_x86</span><span class="o">*</span> <span class="n">x86</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inst</span><span class="p">.</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">.</span><span class="n">op_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cs_x86_op</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    
    <span class="c1">//mem type is rip relative, like lea rcx,[rip+0xbeef]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">X86_OP_MEM</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">//if we're relative to rip</span>
      <span class="k">return</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">base</span> <span class="o">==</span> <span class="n">X86_REG_RIP</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Relocating an instruction that’s been identified as having a rip-relative operand is a bit more of a bear. Remember how I mentioned that we’re going to put our trampoline in memory that’s within a 32 bit jump of our target function? That’s to try to avoid cases where the new offset we compute is too large to be stored in the existing instruction’s operand.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">GetDisplacement</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">disp</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">disp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//rewrite instruction bytes so that any RIP-relative displacement operands</span>
<span class="c1">//make sense with wherever we're relocating to</span>
<span class="kt">void</span> <span class="nf">RelocateInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dstLocation</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cs_x86</span><span class="o">*</span> <span class="n">x86</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">);</span>
  <span class="kt">uint8_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_offset</span><span class="p">;</span>

  <span class="kt">uint64_t</span> <span class="n">displacement</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_offset</span><span class="p">];</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> 
    <span class="p">{</span>
      <span class="kt">int8_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
      <span class="n">disp</span> <span class="o">-=</span> <span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> 
    <span class="p">{</span>
      <span class="kt">int16_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
      <span class="n">disp</span> <span class="o">-=</span> <span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="p">{</span>
      <span class="kt">int32_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
      <span class="n">disp</span> <span class="o">-=</span> <span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Shout out to the <a href="https://github.com/stevemk14ebr/PolyHook/blob/577637181705ac52d2ae05a6db57ea709759ae56/PolyHook/PolyHook.hpp#L878">polyhook source</a> that I stole this logic from.</p>

<p>Plugging these functions into the BuildTrampoline() logic requires adding a check and a function call to the for loop that processes our stolen instructions.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numInstructions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

  <span class="c1">//perform any fixup logic to the stolen instructions here</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">RelocateInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
  <span class="n">stolenByteMem</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Now we can hook our little printf function with wild abandon!</p>

<h3 id="step-3-building-the-absolute-instruction-table">Step 3: Building the Absolute Instruction Table</h3>
<p>Next we need to deal with any relative jump or call instructions in our stolen bytes. After all “jump 10 bytes from here” doesn’t mean very much when the instruction has been moved to a new “here.” I have no idea how to handle loop instructions, so the example code will only deal with jmp and call instructions.</p>

<p>Like with the rip-relative operands, the first thing we need to do is identify whether an instruction is one of the flavors of jmp or call that we care about. Identifying relative calls is pretty easy, because there aren’t that many varieties of call instructions, and all the relative versions have opcodes that start with 0xE8.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">IsRelativeCall</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">isCall</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_CALL</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">startsWithE8</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xE8</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">isCall</span> <span class="o">&amp;&amp;</span> <span class="n">startsWithE8</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Identifying jmps is a little harder because there are lots of different types of jmp instructions. Since conditional jumps <em>only</em> come in relative versions, if an instruction’s id says it’s a conditional jump, we know it uses relative addressing. The unconditional “jmp” instruction <em>can</em> use relative addressing, but it can also do things like jump to an address in a register. Thankfully, the behaviour of a jmp is dictated by it’s opcode bytes. Relative jmps start with 0xEB and 0xE9.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">IsRelativeJump</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">isAnyJumpInstruction</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_JAE</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_JS</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">isJmp</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_JMP</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">startsWithEBorE9</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xEB</span> <span class="o">||</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xE9</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">isJmp</span> <span class="o">?</span> <span class="n">startsWithEBorE9</span> <span class="o">:</span> <span class="n">isAnyJumpInstruction</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>We can use these two functions to quickly identify any stolen instructions that are going to require extra attention:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numInstructions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_LOOP</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_LOOPNE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//bail out on loop instructions, I don't have a good way of handling them </span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">RelocateInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsRelativeJump</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
  <span class="p">{</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsRelativeCall</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
  <span class="p">{</span>
  <span class="p">}</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
  <span class="n">stolenByteMem</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Next We need to figure out the address that the original instruction wanted to go to, and add an absolute jump (or call) to that address to our Absolute Instruction Table. The Capstone library handles calculating the target address of relative instructions for us automatically, which is handy.</p>

<p>Jumps are easier to handle than calls, so we’ll start there. We’ll reuse the WriteAbsoluteJump64 function from earlier in this post to make the code a bit more concise.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">uint32_t</span> <span class="nf">AddJmpToAbsTable</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">jmp</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">targetAddrStr</span> <span class="o">=</span> <span class="n">jmp</span><span class="p">.</span><span class="n">op_str</span><span class="p">;</span> <span class="c1">//where the instruction intended to go</span>
  <span class="kt">uint64_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">_strtoui64</span><span class="p">(</span><span class="n">targetAddrStr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">absTableMem</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">13</span><span class="p">;</span> <span class="c1">//size of mov/jmp instrs for absolute jump</span>
<span class="p">}</span></code></pre></div>

<p>Note that this function doesn’t rewrite the existing jump instruction, it only adds an absolute version of it to the absolute instruction table (AIT). We’ll handle pointing the original jump to this AIT entry later in this post.</p>

<p>Dealing with calls is a bit different. If we just add an absolute call instruction to our AIT, when that call returns, we’ll wind up at the next jump in the table. That would be bad, so instead we also need to add a jump instruction after our absolute calls to redirect program flow to somewhere more helpful. In this case, we’ll jump to the middle of our trampoline, which is the jump back to the hooked function’s body.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">uint32_t</span> <span class="nf">AddCallToAbsTable</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">call</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">jumpBackToHookedFunc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">targetAddrStr</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">op_str</span><span class="p">;</span> <span class="c1">//where the instruction intended to go</span>
  <span class="kt">uint64_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">_strtoui64</span><span class="p">(</span><span class="n">targetAddrStr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">dstMem</span> <span class="o">=</span> <span class="n">absTableMem</span><span class="p">;</span>

  <span class="kt">uint8_t</span> <span class="n">callAsmBytes</span><span class="p">[]</span> <span class="o">=</span>
  <span class="p">{</span>
    <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="c1">//movabs 64 bit value into r10</span>
    <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xD2</span><span class="p">,</span> <span class="c1">//call r10</span>
  <span class="p">};</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callAsmBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">targetAddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">dstMem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callAsmBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">));</span>
  <span class="n">dstMem</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">);</span>

  <span class="c1">//after the call, we need to add a second 2 byte jump, which will jump back to the </span>
    <span class="c1">//final jump of the stolen bytes</span>
  <span class="kt">uint8_t</span> <span class="n">jmpBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="n">jumpBackToHookedFunc</span> <span class="o">-</span> <span class="p">(</span><span class="n">absTableMem</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">))</span> <span class="p">};</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">dstMem</span><span class="p">,</span> <span class="n">jmpBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">));</span>

  <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">);</span> <span class="c1">//15</span>
<span class="p">}</span></code></pre></div>

<p>You’ve probably noticed that both of these functions return the number of bytes that they wrote to the AIT. This is so we can increment the absTableMem pointer in BuildTrampoline(). These calls should be added inside the IsRelativeJump()/IsRelativeCall() conditionals in the BuildTrampoline() function.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numInstructions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_LOOP</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_LOOPNE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//bail out on loop instructions, I don't have a good way of handling them </span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">RelocateInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsRelativeJump</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
  <span class="p">{</span>
      <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddJmpToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
      <span class="c1">//rewrite inst here</span>
      <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsRelativeCall</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
  <span class="p">{</span>
      <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddCallToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">,</span> <span class="n">jumpBackMem</span><span class="p">);</span>
      <span class="c1">//rewrite inst here</span>
      <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
  <span class="n">stolenByteMem</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h3 id="step-4-rewriting-jumpscalls-to-use-the-ait">Step 4: Rewriting Jumps/Calls to Use the AIT.</h3>
<p>Adding instructions to the Absolute Instruction Table is great and all, but in order for any of that work to matter, we also need to rewrite our stolen relative instructions to actually go to the AIT. Similar to the last step, this needs to be handled differently for jumps vs calls.</p>

<p>Calls are the easier of the two to rewrite, so we’ll start with them. Since all call instructions are unconditional, we can replace any relative calls with jumps to the appropriate address inside the AIT. We know that our trampoline won’t be larger than 255 bytes, so we can use a 2 byte jmp instruction for this. We don’t want to change the size of the call instruction we’re rewriting, so we’ll first replace all the bytes for that instruction with NOPs. That way, if we rewrite a 4 byte call with a 2 byte jmp, we haven’t added garbage instructions to the trampoline.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">RewriteCallInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">instr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">instrPtr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableEntry</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">distToJumpTable</span> <span class="o">=</span> <span class="n">absTableEntry</span> <span class="o">-</span> <span class="p">(</span><span class="n">instrPtr</span> <span class="o">+</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

  <span class="c1">//calls need to be rewritten as relative jumps to the abs table</span>
  <span class="c1">//but we want to preserve the length of the instruction, so pad with NOPs</span>
  <span class="kt">uint8_t</span> <span class="n">jmpBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="n">distToJumpTable</span> <span class="p">};</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> <span class="n">jmpBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>

<p>Jumps are more of a pain. There are a lot of different jump instructions that we might encounter, many of which are some flavor of a conditional jump. We can’t replace these instructions with a normal jmp because that could change the execution logic of our stolen bytes. Instead we need to rewrite the operands directly, so that these jumps will conditionally jump to the Absolute Instruction Table.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">RewriteJumpInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">instr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">instrPtr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableEntry</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">distToJumpTable</span> <span class="o">=</span> <span class="n">absTableEntry</span> <span class="o">-</span> <span class="p">(</span><span class="n">instrPtr</span> <span class="o">+</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span> 

  <span class="c1">//jmp instructions can have a 1 or 2 byte opcode, and need a 1-4 byte operand</span>
  <span class="c1">//rewrite the operand for the jump to go to the jump table</span>
  <span class="kt">uint8_t</span> <span class="n">instrByteSize</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0F</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">operandSize</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">instrByteSize</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">operandSize</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="p">}</span><span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="kt">uint16_t</span> <span class="n">dist16</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dist16</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="kt">uint32_t</span> <span class="n">dist32</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dist32</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>The snippet below shows how these new functions should be added to BuildTrampoline(). Notice that we need to wait until after calling these new rewrite functions before we can increment the absTableMem pointer.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">uint32_t</span> <span class="nf">BuildTrampoline</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dstMemForTrampoline</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">X64Instructions</span> <span class="n">stolenInstrs</span> <span class="o">=</span> <span class="n">StealBytes</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>

  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">stolenByteMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">dstMemForTrampoline</span><span class="p">;</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">jumpBackMem</span> <span class="o">=</span> <span class="n">stolenByteMem</span> <span class="o">+</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numBytes</span><span class="p">;</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span> <span class="o">=</span> <span class="n">jumpBackMem</span> <span class="o">+</span> <span class="mi">13</span><span class="p">;</span> <span class="c1">//13 is the size of a 64 bit mov/jmp instruction pair</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numInstructions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_LOOP</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_LOOPNE</span><span class="p">){</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//bail out on loop instructions, I don't have a good way of handling them </span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">IsRelativeJump</span><span class="p">(</span><span class="n">inst</span><span class="p">)){</span>
      <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddJmpToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
      <span class="n">RewriteJumpInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
      <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_CALL</span><span class="p">){</span>
      <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddCallToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">,</span> <span class="n">jumpBackMem</span><span class="p">);</span>
      <span class="n">RewriteCallInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
      <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//write stolen instruction (rewritten or otherwise) to trmapoline mem</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
    <span class="n">stolenByteMem</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
  <span class="p">}</span>

   <span class="c1">//write jump back to hooked func</span>

  <span class="n">free</span><span class="p">(</span><span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">);</span>
  <span class="k">return</span> <span class="kt">uint32_t</span><span class="p">(</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">absTableMem</span> <span class="o">-</span> <span class="n">dstMemForTrampoline</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<h3 id="step-5-write-the-jump-back-to-the-hooked-functions-body">Step 5: Write the Jump Back to the Hooked Function’s Body</h3>
<p>This has been a long process, but we’re almost there. Now we need to fill in the middle of the jump sandwich, and return our trampoline’s size. After all the work we’ve done so far, this last step doesn’t need much explanation. All we need to do is replace the comment in the snippet above with the following:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">jumpBackMem</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span></code></pre></div>

<p>When we stole the bytes from func2hook, we also replaced them with NOP instructions. This makes our life easier here, since the jump back to our hooked function doesn’t have to care about the number of bytes we stole. Jumping to the byte immediately after the hook’s jump is guaranteed to be safe.</p>

<p>Finally we return the byte count of our trampoline, so that InstallHook() can write the relay function into memory right after our trampoline bytes.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunc</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">trampolinePtr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
  <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

  <span class="kt">void</span><span class="o">*</span> <span class="n">hookMemory</span> <span class="o">=</span> <span class="n">AllocatePageNearAddress</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">trampolineSize</span> <span class="o">=</span> <span class="n">BuildTrampoline</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">hookMemory</span><span class="p">);</span>
  <span class="o">*</span><span class="n">trampolinePtr</span> <span class="o">=</span> <span class="n">hookMemory</span><span class="p">;</span>

  <span class="c1">//create the relay function</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">relayFuncMemory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hookMemory</span> <span class="o">+</span> <span class="n">trampolineSize</span><span class="p">;</span>
  <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">relayFuncMemory</span><span class="p">,</span> <span class="n">payloadFunc</span><span class="p">);</span> <span class="c1">//write relay func instructions</span>

  <span class="c1">//install the hook</span>
  <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>
  <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">relayFuncMemory</span> <span class="o">-</span> <span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>

<p>aaaaand we’re done! The collapsebox below shows the full source for a program that uses this trampoline to hook a function. We’ve already talked about all the fun parts, so I’m going to leave it here without comment and move on to the grand finale.</p>

<div class="collapsewrapper2">
<details class="collapsible">
    <summary>Full Example of Trampoline Hooking a Function In The Same Process As The Hook Code</summary>

    <div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;cstdlib&gt;
#include "capstone/x86.h"
#include "capstone/capstone.h"
#include &lt;vector&gt;
#include &lt;Windows.h&gt;
</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">noinline</span><span class="p">)</span> <span class="kt">void</span> <span class="nf">TargetFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Target Func: x &gt; 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="p">}</span>

<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">TargetFuncTrampoline</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="p">)</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">HookPayload</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hook executed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">TargetFuncTrampoline</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">AllocatePageNearAddress</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">targetAddr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SYSTEM_INFO</span> <span class="n">sysInfo</span><span class="p">;</span>
    <span class="n">GetSystemInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysInfo</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="n">sysInfo</span><span class="p">.</span><span class="n">dwPageSize</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">startAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">targetAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">//round down to nearest page boundary</span>
    <span class="kt">uint64_t</span> <span class="n">minAddr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMinimumApplicationAddress</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">maxAddr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">+</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMaximumApplicationAddress</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">startPage</span> <span class="o">=</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

    <span class="kt">uint64_t</span> <span class="n">pageOffset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="n">pageOffset</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">highAddr</span> <span class="o">=</span> <span class="n">startPage</span> <span class="o">+</span> <span class="n">byteOffset</span><span class="p">;</span>
	    	<span class="kt">uint64_t</span> <span class="n">lowAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">startPage</span> <span class="o">&gt;</span> <span class="n">byteOffset</span><span class="p">)</span> <span class="o">?</span> <span class="n">startPage</span> <span class="o">-</span> <span class="n">byteOffset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">needsExit</span> <span class="o">=</span> <span class="n">highAddr</span> <span class="o">&gt;</span> <span class="n">maxAddr</span> <span class="o">&amp;&amp;</span> <span class="n">lowAddr</span> <span class="o">&lt;</span> <span class="n">minAddr</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">highAddr</span> <span class="o">&lt;</span> <span class="n">maxAddr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">highAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lowAddr</span> <span class="o">&gt;</span> <span class="n">minAddr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">lowAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pageOffset</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">needsExit</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WriteAbsoluteJump64</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">absJumpMemory</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addrToJumpTo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">absJumpInstructions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
                      <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xE2</span> <span class="p">};</span>

    <span class="kt">uint64_t</span> <span class="n">addrToJumpTo64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">addrToJumpTo</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">absJumpInstructions</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrToJumpTo64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrToJumpTo64</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">absJumpMemory</span><span class="p">,</span> <span class="n">absJumpInstructions</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">absJumpInstructions</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">X64Instructions</span>
<span class="p">{</span>
    <span class="n">cs_insn</span><span class="o">*</span> <span class="n">instructions</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">numInstructions</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">numBytes</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">X64Instructions</span> <span class="nf">StealBytes</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Disassemble stolen bytes</span>
    <span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>
    <span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
    <span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_DETAIL</span><span class="p">,</span> <span class="n">CS_OPT_ON</span><span class="p">);</span> <span class="c1">// we need details enabled for relocating RIP relative instrs</span>

    <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">cs_insn</span><span class="o">*</span> <span class="n">disassembledInstructions</span><span class="p">;</span> <span class="c1">//allocated by cs_disasm, needs to be manually freed later</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">cs_disasm</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">function</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">function</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disassembledInstructions</span><span class="p">);</span>

    <span class="c1">//get the instructions covered by the first 5 bytes of the original function</span>
    <span class="kt">uint32_t</span> <span class="n">byteCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">stolenInstrCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">disassembledInstructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">byteCount</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
        <span class="n">stolenInstrCount</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">byteCount</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//replace instructions in target func wtih NOPs</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="n">byteCount</span><span class="p">);</span>

    <span class="n">cs_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">disassembledInstructions</span><span class="p">,</span> <span class="n">stolenInstrCount</span><span class="p">,</span> <span class="n">byteCount</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">IsRelativeJump</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">isAnyJumpInstruction</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_JAE</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_JS</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">isJmp</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_JMP</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">startsWithEBorE9</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xEB</span> <span class="o">||</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xE9</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">isJmp</span> <span class="o">?</span> <span class="n">startsWithEBorE9</span> <span class="o">:</span> <span class="n">isAnyJumpInstruction</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">IsRelativeCall</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">isCall</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_CALL</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">startsWithE8</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xE8</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">isCall</span> <span class="o">&amp;&amp;</span> <span class="n">startsWithE8</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">RewriteJumpInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">instr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">instrPtr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableEntry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">distToJumpTable</span> <span class="o">=</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">absTableEntry</span> <span class="o">-</span> <span class="p">(</span><span class="n">instrPtr</span> <span class="o">+</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>

    <span class="c1">//jmp instructions can have a 1 or 2 byte opcode, and need a 1-4 byte operand</span>
    <span class="c1">//rewrite the operand for the jump to go to the jump table</span>
    <span class="kt">uint8_t</span> <span class="n">instrByteSize</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0F</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">operandSize</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">instrByteSize</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">operandSize</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="kt">uint16_t</span> <span class="n">dist16</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dist16</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="kt">uint32_t</span> <span class="n">dist32</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dist32</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">RewriteCallInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">instr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">instrPtr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableEntry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">distToJumpTable</span> <span class="o">=</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">absTableEntry</span> <span class="o">-</span> <span class="p">(</span><span class="n">instrPtr</span> <span class="o">+</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>

    <span class="c1">//calls need to be rewritten as relative jumps to the abs table</span>
    <span class="c1">//but we want to preserve the length of the instruction, so pad with NOPs</span>
    <span class="kt">uint8_t</span> <span class="n">jmpBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="n">distToJumpTable</span> <span class="p">};</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> <span class="n">jmpBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">AddJmpToAbsTable</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">jmp</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">targetAddrStr</span> <span class="o">=</span> <span class="n">jmp</span><span class="p">.</span><span class="n">op_str</span><span class="p">;</span> <span class="c1">//where the instruction intended to go</span>
    <span class="kt">uint64_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">_strtoui64</span><span class="p">(</span><span class="n">targetAddrStr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">absTableMem</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">13</span><span class="p">;</span> <span class="c1">//size of mov/jmp instrs for absolute jump</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">AddCallToAbsTable</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">call</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">jumpBackToHookedFunc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">targetAddrStr</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">op_str</span><span class="p">;</span> <span class="c1">//where the instruction intended to go</span>
    <span class="kt">uint64_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">_strtoui64</span><span class="p">(</span><span class="n">targetAddrStr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">dstMem</span> <span class="o">=</span> <span class="n">absTableMem</span><span class="p">;</span>

    <span class="kt">uint8_t</span> <span class="n">callAsmBytes</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span>
      <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="c1">//movabs 64 bit value into r10</span>
      <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xD2</span><span class="p">,</span> <span class="c1">//call r10</span>
    <span class="p">};</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callAsmBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">targetAddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dstMem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callAsmBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">));</span>
    <span class="n">dstMem</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">);</span>

    <span class="c1">//after the call, we need to add a second 2 byte jump, which will jump back to the </span>
      <span class="c1">//final jump of the stolen bytes</span>
    <span class="kt">uint8_t</span> <span class="n">jmpBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">jumpBackToHookedFunc</span> <span class="o">-</span> <span class="p">(</span><span class="n">absTableMem</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">)))</span> <span class="p">};</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dstMem</span><span class="p">,</span> <span class="n">jmpBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">));</span>

    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">);</span> <span class="c1">//15</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cs_x86</span><span class="o">*</span> <span class="n">x86</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inst</span><span class="p">.</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">.</span><span class="n">op_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cs_x86_op</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="c1">//mem type is rip relative, like lea rcx,[rip+0xbeef]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">X86_OP_MEM</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//if we're relative to rip</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">base</span> <span class="o">==</span> <span class="n">X86_REG_RIP</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">GetDisplacement</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">disp</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">disp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//rewrite instruction bytes so that any RIP-relative displacement operands</span>
<span class="c1">//make sense with wherever we're relocating to</span>
<span class="kt">void</span> <span class="nf">RelocateInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dstLocation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cs_x86</span><span class="o">*</span> <span class="n">x86</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">);</span>
    <span class="kt">uint8_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_offset</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">displacement</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_offset</span><span class="p">];</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_size</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="kt">int8_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
        <span class="n">disp</span> <span class="o">-=</span> <span class="kt">int8_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="kt">int16_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
        <span class="n">disp</span> <span class="o">-=</span> <span class="kt">int16_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
        <span class="n">disp</span> <span class="o">-=</span> <span class="kt">int32_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">BuildTrampoline</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dstMemForTrampoline</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">X64Instructions</span> <span class="n">stolenInstrs</span> <span class="o">=</span> <span class="n">StealBytes</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>

    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">stolenByteMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">dstMemForTrampoline</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">jumpBackMem</span> <span class="o">=</span> <span class="n">stolenByteMem</span> <span class="o">+</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numBytes</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span> <span class="o">=</span> <span class="n">jumpBackMem</span> <span class="o">+</span> <span class="mi">13</span><span class="p">;</span> <span class="c1">//13 is the size of a 64 bit mov/jmp instruction pair</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numInstructions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_LOOP</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_LOOPNE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//bail out on loop instructions, I don't have a good way of handling them </span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">RelocateInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsRelativeJump</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddJmpToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
            <span class="n">RewriteJumpInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
            <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_CALL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddCallToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">,</span> <span class="n">jumpBackMem</span><span class="p">);</span>
            <span class="n">RewriteCallInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
            <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">stolenByteMem</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">jumpBackMem</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">);</span>

    <span class="k">return</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">absTableMem</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">dstMemForTrampoline</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunc</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">trampolinePtr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
    <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

    <span class="kt">void</span><span class="o">*</span> <span class="n">hookMemory</span> <span class="o">=</span> <span class="n">AllocatePageNearAddress</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">trampolineSize</span> <span class="o">=</span> <span class="n">BuildTrampoline</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">hookMemory</span><span class="p">);</span>
    <span class="o">*</span><span class="n">trampolinePtr</span> <span class="o">=</span> <span class="n">hookMemory</span><span class="p">;</span>

    <span class="c1">//create the relay function</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">relayFuncMemory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hookMemory</span> <span class="o">+</span> <span class="n">trampolineSize</span><span class="p">;</span>
    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">relayFuncMemory</span><span class="p">,</span> <span class="n">payloadFunc</span><span class="p">);</span> <span class="c1">//write relay func instructions</span>

    <span class="c1">//install the hook</span>
    <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">relayFuncMemory</span> <span class="o">-</span> <span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TargetFunc</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InstallHook</span><span class="p">(</span><span class="n">TargetFunc</span><span class="p">,</span> <span class="n">HookPayload</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">TargetFuncTrampoline</span><span class="p">);</span>
    <span class="n">TargetFunc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

  </details></div>

<h2 id="example-4-using-a-trampoline-to-hook-a-running-program">Example 4: Using a Trampoline to Hook a Running Program</h2>
<p>Like Po at the end of Kung Fu Panda, it’s time to put all our newfound skills to use and fulfill our destiny of becoming the dragon warrior.</p>

<p>The last example is going to use a trampoline to force mspaint to always use the color orange, no matter what color the user tries to select. This was shown in the gif at the start of article, but it’s been a long time since then, so here that gif is again:</p>

<div align="center">
<img src="/images/post_images/2020-11-13/orangepaint.gif" />
<br /><br />
</div>

<p>Mercifully for us, we don’t need to go on an RVA fishing trip this time, because the function we want to hook is exported from a DLL. We’re going to install a hook into gdiplus.dll’s GdipSetSolidFillColor() function. Finding out that this was the right function to hook was pretty much the same process as the last mspaint example: lots of trial and error with breakpoints in x64dbg. A reverse engineer I am not.</p>

<p>So, here’s the plan:</p>

<ol>
  <li>Write a hook payload function that intercepts calls to GdipSetSolidFillColor and replaces the incoming function arguments with the color orange.</li>
  <li>Put that payload in a DLL, along with all the hooking logic required to make it happen</li>
  <li>Inject that DLL into a running instance of mspaint</li>
  <li>Make beautiful artwork with the best color ever.</li>
</ol>

<p>We’ve already exhaustively walked through a code example that used the same hooking logic that we need to use here. Rather than do that again, let’s focus on what’s different this time. Looking up GdipSetSolidFillColor() gives us this function signature:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">GpStatus</span> <span class="n">WINGDIPAPI</span> <span class="n">GdipSetSolidFillColor</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpSolidFill</span> <span class="o">*</span><span class="n">brush</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">color</span><span class="p">)</span></code></pre></div>

<p>Recall that the ARGB type is a uint32 with each byte representing a color channel. This means that all our payload need to do to make things orange is set some bits and pass the new ARGB value to the trampoline:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpStatus</span><span class="p">(</span><span class="o">*</span><span class="n">GdipSetSolidFillColorTrampoline</span><span class="p">)(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpSolidFill</span><span class="o">*</span> <span class="n">brush</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">color</span><span class="p">);</span>
<span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpStatus</span> <span class="nf">GdipSetSolidFillColorPayload</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpSolidFill</span><span class="o">*</span> <span class="n">brush</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">orange</span> <span class="o">=</span> <span class="mh">0xffff7700</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">GdipSetSolidFillColorTrampoline</span><span class="p">(</span><span class="n">brush</span><span class="p">,</span> <span class="n">orange</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>This isn’t going to be enough to make ALL the possible painting tools spit out orange all the time. The paint can tool, spray paint brushes, etc will still use the colors selected. Our dll will just make most brushes always paint orange, which is good enough for me. It’ll also totally mess with the output of some brushes and make them operate weirdly too, which is fun in its own way.</p>

<p>Here’s a gif demonstrating some of the tools <em>not</em> painting orange, despite our dll being injected into paint:</p>

<div align="center">
<img src="/images/post_images/2020-11-13/orangepaint_problems.gif" />
<br /><br />
</div>

<p>The hooking logic that we include in the DLL is going to similar to the trampoline code we wrote for Example 3. The main difference is how we get a pointer to the function we want to hook.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpvReserved</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ul_reason_for_call</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">HMODULE</span> <span class="n">gdiPlusModule</span> <span class="o">=</span> <span class="n">FindModuleInProcess</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="s">"gdiplus.dll"</span><span class="p">));</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">localHookFunc4</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">gdiPlusModule</span><span class="p">,</span> <span class="p">(</span><span class="s">"GdipSetSolidFillColor"</span><span class="p">));</span>
    <span class="n">InstallHook</span><span class="p">(</span><span class="n">localHookFunc4</span><span class="p">,</span> <span class="n">GdipSetSolidFillColorPayload</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>The FindModuleInProcess() function called above is similar to the GetBaseModuleForProcess() function that we used in a previous example, except that it can look for any loaded module by string name. The function is a bit long, so rather than paste it here, I’ve included it in the complete source for this example. The program used to inject this dll into paint is the same as the one we used before, but it’s also included below.</p>

<p>It took a while to get here, but we’re finally done Example 4! Go celebrate by making beautiful orange artwork!</p>

<div class="collapsewrapper2">
<details class="collapsible">
    <summary>Full Source For DLL Injector Program (click to expand)</summary>

    <div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">//Injector_LoadLibrary is a dll injector that uses LoadLibraryA to inject a dll into a running process</span>
<span class="c1">// usage: Injector_LoadLibrary &lt;process name&gt; &lt;path to dll&gt; </span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt; //for PROCESSENTRY32, needs to be included after windows.h
</span>
<span class="kt">void</span> <span class="nf">printHelp</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Injector_LoadLibrary</span><span class="se">\n</span><span class="s">Usage: Injector_LoadLibrary &lt;process name&gt; &lt;path to dll&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">createRemoteThread</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">processID</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">dllPath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span>
        <span class="n">PROCESS_QUERY_INFORMATION</span> <span class="o">|</span> <span class="c1">//Needed to get a process' token</span>
        <span class="n">PROCESS_CREATE_THREAD</span> <span class="o">|</span>    <span class="c1">//for obvious reasons</span>
        <span class="n">PROCESS_VM_OPERATION</span> <span class="o">|</span>    <span class="c1">//required to perform operations on address space of process (like WriteProcessMemory)</span>
        <span class="n">PROCESS_VM_WRITE</span><span class="p">,</span>  <span class="c1">//required for WriteProcessMemory</span>
        <span class="n">FALSE</span><span class="p">,</span>      <span class="c1">//don't inherit handle</span>
        <span class="n">processID</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not open process with pid: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//once the process is open, we need to write the name of our dll to that process' memory</span>
    <span class="kt">size_t</span> <span class="n">dllPathLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dllPath</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">dllPathRemote</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span>
        <span class="n">handle</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//let the system decide where to allocate the memory</span>
        <span class="n">dllPathLen</span><span class="p">,</span>
        <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="c1">//actually commit the virtual memory</span>
        <span class="n">PAGE_READWRITE</span><span class="p">);</span> <span class="c1">//mem access for committed page</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dllPathRemote</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not allocate %zd bytes in process with pid: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dllPathLen</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">BOOL</span> <span class="n">writeSucceeded</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span><span class="p">(</span>
        <span class="n">handle</span><span class="p">,</span>
        <span class="n">dllPathRemote</span><span class="p">,</span>
        <span class="n">dllPath</span><span class="p">,</span>
        <span class="n">dllPathLen</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writeSucceeded</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not write %zd bytes to process with pid %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dllPathLen</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//now get address of LoadLibraryW function inside Kernel32.dll</span>
    <span class="c1">//TEXT macro "Identifies a string as Unicode when UNICODE is defined by a preprocessor directive during compilation. Otherwise, ANSI string"</span>
    <span class="n">PTHREAD_START_ROUTINE</span> <span class="n">loadLibraryFunc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Kernel32.dll"</span><span class="p">)),</span> <span class="s">"LoadLibraryA"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loadLibraryFunc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not find LoadLibraryA function inside kernel32.dll</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//now create a thread in remote process that loads our target dll using LoadLibraryA</span>

    <span class="n">HANDLE</span> <span class="n">remoteThread</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span>
        <span class="n">handle</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//default thread security</span>
        <span class="mi">0</span><span class="p">,</span> <span class="c1">//stack size for thread</span>
        <span class="n">loadLibraryFunc</span><span class="p">,</span> <span class="c1">//pointer to start of thread function (for us, LoadLibraryA)</span>
        <span class="n">dllPathRemote</span><span class="p">,</span> <span class="c1">//pointer to variable being passed to thread function</span>
        <span class="mi">0</span><span class="p">,</span> <span class="c1">//0 means the thread runs immediately after creation</span>
        <span class="nb">NULL</span><span class="p">);</span> <span class="c1">//we don't care about getting back the thread identifier</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">remoteThread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Could not create remote thread.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"Success! remote thread started in process %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">processID</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Wait for the remote thread to terminate</span>
    <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">remoteThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

    <span class="c1">//once we're done, free the memory we allocated in the remote process for the dllPathname, and shut down</span>
    <span class="n">VirtualFreeEx</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dllPathRemote</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">remoteThread</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="nf">findPidByName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">singleProcess</span><span class="p">;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span> <span class="c1">//takes a snapshot of specified processes</span>
        <span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="c1">//get all processes</span>
        <span class="mi">0</span><span class="p">);</span> <span class="c1">//ignored for SNAPPROCESS</span>

    <span class="n">singleProcess</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

    <span class="k">do</span> <span class="p">{</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">singleProcess</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">DWORD</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">singleProcess</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"PID Found: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
            <span class="n">CloseHandle</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32Next</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">singleProcess</span><span class="p">));</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printHelp</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">createRemoteThread</span><span class="p">(</span><span class="n">findPidByName</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

  </details></div>

<div class="collapsewrapper2">
<details class="collapsible">
    <summary>Full Source For Example 4 (click to expand)</summary>

    <div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;cstdlib&gt;
#include "capstone/x86.h"
#include "capstone/capstone.h"
#include &lt;vector&gt;
#include &lt;Windows.h&gt;
#include &lt;gdiplus.h&gt;
#include &lt;Psapi.h&gt;
#pragma comment (lib, "Gdiplus.lib")
</span>
<span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpStatus</span><span class="p">(</span><span class="o">*</span><span class="n">GdipSetSolidFillColorTrampoline</span><span class="p">)(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpSolidFill</span><span class="o">*</span> <span class="n">brush</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">color</span><span class="p">);</span>
<span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpStatus</span> <span class="nf">GdipSetSolidFillColorPayload</span><span class="p">(</span><span class="n">Gdiplus</span><span class="o">::</span><span class="n">GpSolidFill</span><span class="o">*</span> <span class="n">brush</span><span class="p">,</span> <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Gdiplus</span><span class="o">::</span><span class="n">ARGB</span> <span class="n">orange</span> <span class="o">=</span> <span class="mh">0xffff7700</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">GdipSetSolidFillColorTrampoline</span><span class="p">(</span><span class="n">brush</span><span class="p">,</span> <span class="n">orange</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">AllocatePageNearAddress</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">targetAddr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SYSTEM_INFO</span> <span class="n">sysInfo</span><span class="p">;</span>
    <span class="n">GetSystemInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysInfo</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="n">sysInfo</span><span class="p">.</span><span class="n">dwPageSize</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">startAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">targetAddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">//round down to nearest page boundary</span>
    <span class="kt">uint64_t</span> <span class="n">minAddr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMinimumApplicationAddress</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">maxAddr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">startAddr</span> <span class="o">+</span> <span class="mh">0x7FFFFF00</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">sysInfo</span><span class="p">.</span><span class="n">lpMaximumApplicationAddress</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">startPage</span> <span class="o">=</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">-</span> <span class="p">(</span><span class="n">startAddr</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

    <span class="kt">uint64_t</span> <span class="n">pageOffset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="n">pageOffset</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">highAddr</span> <span class="o">=</span> <span class="n">startPage</span> <span class="o">+</span> <span class="n">byteOffset</span><span class="p">;</span>
		    <span class="kt">uint64_t</span> <span class="n">lowAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">startPage</span> <span class="o">&gt;</span> <span class="n">byteOffset</span><span class="p">)</span> <span class="o">?</span> <span class="n">startPage</span> <span class="o">-</span> <span class="n">byteOffset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">needsExit</span> <span class="o">=</span> <span class="n">highAddr</span> <span class="o">&gt;</span> <span class="n">maxAddr</span> <span class="o">&amp;&amp;</span> <span class="n">lowAddr</span> <span class="o">&lt;</span> <span class="n">minAddr</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">highAddr</span> <span class="o">&lt;</span> <span class="n">maxAddr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">highAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lowAddr</span> <span class="o">&gt;</span> <span class="n">minAddr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">void</span><span class="o">*</span> <span class="n">outAddr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">lowAddr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outAddr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">outAddr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pageOffset</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">needsExit</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WriteAbsoluteJump64</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">absJumpMemory</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addrToJumpTo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">absJumpInstructions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
                      <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xE2</span> <span class="p">};</span>

    <span class="kt">uint64_t</span> <span class="n">addrToJumpTo64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">addrToJumpTo</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">absJumpInstructions</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrToJumpTo64</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addrToJumpTo64</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">absJumpMemory</span><span class="p">,</span> <span class="n">absJumpInstructions</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">absJumpInstructions</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">X64Instructions</span>
<span class="p">{</span>
    <span class="n">cs_insn</span><span class="o">*</span> <span class="n">instructions</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">numInstructions</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">numBytes</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">X64Instructions</span> <span class="nf">StealBytes</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Disassemble stolen bytes</span>
    <span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>
    <span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
    <span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_DETAIL</span><span class="p">,</span> <span class="n">CS_OPT_ON</span><span class="p">);</span> <span class="c1">// we need details enabled for relocating RIP relative instrs</span>

    <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">cs_insn</span><span class="o">*</span> <span class="n">disassembledInstructions</span><span class="p">;</span> <span class="c1">//allocated by cs_disasm, needs to be manually freed later</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">cs_disasm</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">function</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">function</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disassembledInstructions</span><span class="p">);</span>

    <span class="c1">//get the instructions covered by the first 5 bytes of the original function</span>
    <span class="kt">uint32_t</span> <span class="n">byteCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">stolenInstrCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">disassembledInstructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">byteCount</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
        <span class="n">stolenInstrCount</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">byteCount</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//replace instructions in target func with NOPs</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="n">byteCount</span><span class="p">);</span>

    <span class="n">cs_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">disassembledInstructions</span><span class="p">,</span> <span class="n">stolenInstrCount</span><span class="p">,</span> <span class="n">byteCount</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">IsRelativeJump</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">isAnyJumpInstruction</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_JAE</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_JS</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">isJmp</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_JMP</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">startsWithEBorE9</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xEB</span> <span class="o">||</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xE9</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">isJmp</span> <span class="o">?</span> <span class="n">startsWithEBorE9</span> <span class="o">:</span> <span class="n">isAnyJumpInstruction</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">IsRelativeCall</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">isCall</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_CALL</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">startsWithE8</span> <span class="o">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xE8</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">isCall</span> <span class="o">&amp;&amp;</span> <span class="n">startsWithE8</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">RewriteJumpInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">instr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">instrPtr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableEntry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">distToJumpTable</span> <span class="o">=</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">absTableEntry</span> <span class="o">-</span> <span class="p">(</span><span class="n">instrPtr</span> <span class="o">+</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>

    <span class="c1">//jmp instructions can have a 1 or 2 byte opcode, and need a 1-4 byte operand</span>
    <span class="c1">//rewrite the operand for the jump to go to the jump table</span>
    <span class="kt">uint8_t</span> <span class="n">instrByteSize</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x0F</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">operandSize</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">instrByteSize</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">operandSize</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="kt">uint16_t</span> <span class="n">dist16</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dist16</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="kt">uint32_t</span> <span class="n">dist32</span> <span class="o">=</span> <span class="n">distToJumpTable</span><span class="p">;</span> <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">instrByteSize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">dist32</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">RewriteCallInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">instr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">instrPtr</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableEntry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">distToJumpTable</span> <span class="o">=</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">absTableEntry</span> <span class="o">-</span> <span class="p">(</span><span class="n">instrPtr</span> <span class="o">+</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>

    <span class="c1">//calls need to be rewritten as relative jumps to the abs table</span>
    <span class="c1">//but we want to preserve the length of the instruction, so pad with NOPs</span>
    <span class="kt">uint8_t</span> <span class="n">jmpBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="n">distToJumpTable</span> <span class="p">};</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> <span class="n">jmpBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">AddJmpToAbsTable</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">jmp</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">targetAddrStr</span> <span class="o">=</span> <span class="n">jmp</span><span class="p">.</span><span class="n">op_str</span><span class="p">;</span> <span class="c1">//where the instruction intended to go</span>
    <span class="kt">uint64_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">_strtoui64</span><span class="p">(</span><span class="n">targetAddrStr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">absTableMem</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">13</span><span class="p">;</span> <span class="c1">//size of mov/jmp instrs for absolute jump</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">AddCallToAbsTable</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">call</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">jumpBackToHookedFunc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">targetAddrStr</span> <span class="o">=</span> <span class="n">call</span><span class="p">.</span><span class="n">op_str</span><span class="p">;</span> <span class="c1">//where the instruction intended to go</span>
    <span class="kt">uint64_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">_strtoui64</span><span class="p">(</span><span class="n">targetAddrStr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">dstMem</span> <span class="o">=</span> <span class="n">absTableMem</span><span class="p">;</span>

    <span class="kt">uint8_t</span> <span class="n">callAsmBytes</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span>
      <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="c1">//movabs 64 bit value into r10</span>
      <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xD2</span><span class="p">,</span> <span class="c1">//call r10</span>
    <span class="p">};</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callAsmBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">targetAddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dstMem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callAsmBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">));</span>
    <span class="n">dstMem</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">);</span>

    <span class="c1">//after the call, we need to add a second 2 byte jump, which will jump back to the </span>
      <span class="c1">//final jump of the stolen bytes</span>
    <span class="kt">uint8_t</span> <span class="n">jmpBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">jumpBackToHookedFunc</span> <span class="o">-</span> <span class="p">(</span><span class="n">absTableMem</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">)))</span> <span class="p">};</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dstMem</span><span class="p">,</span> <span class="n">jmpBytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">));</span>

    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">callAsmBytes</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpBytes</span><span class="p">);</span> <span class="c1">//15</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cs_x86</span><span class="o">*</span> <span class="n">x86</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inst</span><span class="p">.</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">.</span><span class="n">op_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cs_x86_op</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="c1">//mem type is rip relative, like lea rcx,[rip+0xbeef]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">X86_OP_MEM</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//if we're relative to rip</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">base</span> <span class="o">==</span> <span class="n">X86_REG_RIP</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">GetDisplacement</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">disp</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">disp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//rewrite instruction bytes so that any RIP-relative displacement operands</span>
<span class="c1">//make sense with wherever we're relocating to</span>
<span class="kt">void</span> <span class="nf">RelocateInstruction</span><span class="p">(</span><span class="n">cs_insn</span><span class="o">*</span> <span class="n">inst</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dstLocation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cs_x86</span><span class="o">*</span> <span class="n">x86</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">x86</span><span class="p">);</span>
    <span class="kt">uint8_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_offset</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">displacement</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_offset</span><span class="p">];</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">x86</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">.</span><span class="n">disp_size</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="kt">int8_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
        <span class="n">disp</span> <span class="o">-=</span> <span class="kt">int8_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="kt">int16_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
        <span class="n">disp</span> <span class="o">-=</span> <span class="kt">int16_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">disp</span> <span class="o">=</span> <span class="n">GetDisplacement</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
        <span class="n">disp</span> <span class="o">-=</span> <span class="kt">int32_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">dstLocation</span><span class="p">)</span> <span class="o">-</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">disp</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="p">}</span><span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">BuildTrampoline</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dstMemForTrampoline</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">X64Instructions</span> <span class="n">stolenInstrs</span> <span class="o">=</span> <span class="n">StealBytes</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>

    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">stolenByteMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">dstMemForTrampoline</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">jumpBackMem</span> <span class="o">=</span> <span class="n">stolenByteMem</span> <span class="o">+</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numBytes</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">absTableMem</span> <span class="o">=</span> <span class="n">jumpBackMem</span> <span class="o">+</span> <span class="mi">13</span><span class="p">;</span> <span class="c1">//13 is the size of a 64 bit mov/jmp instruction pair</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">numInstructions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cs_insn</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">X86_INS_LOOP</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="n">X86_INS_LOOPNE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//bail out on loop instructions, I don't have a good way of handling them </span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">IsRIPRelativeInstr</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">RelocateInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsRelativeJump</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddJmpToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
            <span class="n">RewriteJumpInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
            <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_CALL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">uint32_t</span> <span class="n">aitSize</span> <span class="o">=</span> <span class="n">AddCallToAbsTable</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">,</span> <span class="n">jumpBackMem</span><span class="p">);</span>
            <span class="n">RewriteCallInstruction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="p">,</span> <span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">absTableMem</span><span class="p">);</span>
            <span class="n">absTableMem</span> <span class="o">+=</span> <span class="n">aitSize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">stolenByteMem</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
        <span class="n">stolenByteMem</span> <span class="o">+=</span> <span class="n">inst</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">jumpBackMem</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">stolenInstrs</span><span class="p">.</span><span class="n">instructions</span><span class="p">);</span>

    <span class="k">return</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">absTableMem</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">dstMemForTrampoline</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">InstallHook</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func2hook</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">payloadFunc</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">trampolinePtr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
    <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

    <span class="kt">void</span><span class="o">*</span> <span class="n">hookMemory</span> <span class="o">=</span> <span class="n">AllocatePageNearAddress</span><span class="p">(</span><span class="n">func2hook</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">trampolineSize</span> <span class="o">=</span> <span class="n">BuildTrampoline</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">hookMemory</span><span class="p">);</span>
    <span class="o">*</span><span class="n">trampolinePtr</span> <span class="o">=</span> <span class="n">hookMemory</span><span class="p">;</span>

    <span class="c1">//create the relay function</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">relayFuncMemory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hookMemory</span> <span class="o">+</span> <span class="n">trampolineSize</span><span class="p">;</span>
    <span class="n">WriteAbsoluteJump64</span><span class="p">(</span><span class="n">relayFuncMemory</span><span class="p">,</span> <span class="n">payloadFunc</span><span class="p">);</span> <span class="c1">//write relay func instructions</span>

    <span class="c1">//install the hook</span>
    <span class="kt">uint8_t</span> <span class="n">jmpInstruction</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">relAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">relayFuncMemory</span> <span class="o">-</span> <span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">func2hook</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">jmpInstruction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relAddr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">func2hook</span><span class="p">,</span> <span class="n">jmpInstruction</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jmpInstruction</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//returns the first module called "name" -&gt; only searches for dll name, not whole path</span>
<span class="c1">//ie: somepath/subdir/mydll.dll can be searched for with "mydll.dll"</span>
<span class="n">HMODULE</span> <span class="nf">FindModuleInProcess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">process</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">lowerCaseName</span> <span class="o">=</span> <span class="n">_strdup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">_strlwr_s</span><span class="p">(</span><span class="n">lowerCaseName</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">HMODULE</span> <span class="n">remoteProcessModules</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">numBytesWrittenInModuleArray</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="n">EnumProcessModules</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">remoteProcessModules</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMODULE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numBytesWrittenInModuleArray</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error enumerating modules on target process. Error Code %lu </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">DebugBreak</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">DWORD</span> <span class="n">numRemoteModules</span> <span class="o">=</span> <span class="n">numBytesWrittenInModuleArray</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMODULE</span><span class="p">);</span>
    <span class="n">CHAR</span> <span class="n">remoteProcessName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">GetModuleFileNameEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">remoteProcessName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span> <span class="c1">//a null module handle gets the process name</span>
    <span class="n">_strlwr_s</span><span class="p">(</span><span class="n">remoteProcessName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="n">MODULEINFO</span> <span class="n">remoteProcessModuleInfo</span><span class="p">;</span>
    <span class="n">HMODULE</span> <span class="n">remoteProcessModule</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//An HMODULE is the DLL's base address </span>

    <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numRemoteModules</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">CHAR</span> <span class="n">moduleName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="n">CHAR</span> <span class="n">absoluteModuleName</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
        <span class="n">CHAR</span> <span class="n">rebasedPath</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
        <span class="n">GetModuleFileNameEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">remoteProcessModules</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">moduleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
        <span class="n">_strlwr_s</span><span class="p">(</span><span class="n">moduleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">lastSlash</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">moduleName</span><span class="p">,</span> <span class="sc">'\\'</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lastSlash</span><span class="p">)</span> <span class="n">lastSlash</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">moduleName</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>

        <span class="kt">char</span><span class="o">*</span> <span class="n">dllName</span> <span class="o">=</span> <span class="n">lastSlash</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dllName</span><span class="p">,</span> <span class="n">lowerCaseName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">remoteProcessModule</span> <span class="o">=</span> <span class="n">remoteProcessModules</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="n">success</span> <span class="o">=</span> <span class="n">GetModuleInformation</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">remoteProcessModules</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">remoteProcessModuleInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MODULEINFO</span><span class="p">));</span>
            <span class="n">free</span><span class="p">(</span><span class="n">lowerCaseName</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">remoteProcessModule</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//the following string operations are to account for cases where GetModuleFileNameEx</span>
        <span class="c1">//returns a relative path rather than an absolute one, the path we get to the module</span>
        <span class="c1">//is using a virtual drive letter (ie: one created by subst) rather than a real drive</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="n">_fullpath</span><span class="p">(</span><span class="n">absoluteModuleName</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">lowerCaseName</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpvReserved</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ul_reason_for_call</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">HMODULE</span> <span class="n">gdiPlusModule</span> <span class="o">=</span> <span class="n">FindModuleInProcess</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="s">"gdiplus.dll"</span><span class="p">);</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">localHookFunc4</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">gdiPlusModule</span><span class="p">,</span> <span class="p">(</span><span class="s">"GdipSetSolidFillColor"</span><span class="p">));</span>
        <span class="n">InstallHook</span><span class="p">(</span><span class="n">localHookFunc4</span><span class="p">,</span> <span class="n">GdipSetSolidFillColorPayload</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GdipSetSolidFillColorTrampoline</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

  </details></div>

<h2 id="where-to-go-next">Where to Go Next</h2>
<p>Despite being by far the longest post I’ve written to date, this rabbit hole goes a whole lot deeper than what I’ve written about here.</p>

<p>First of all, there are significant issues with the code written in this post:</p>

<ul>
  <li>There’s no way to uninstall hooks</li>
  <li>Hooking 32 bit applications isn’t supported at all</li>
  <li>Everything breaks if 2 hooked functions share a payload</li>
  <li>Stuff also breaks if a thread is executing instructions while they’re being stolen</li>
  <li>More stuff breaks if the stolen instructions for a function use the r10 register</li>
  <li>There are at least 3 additional scary problems I don’t know about yet</li>
</ul>

<p>I solve some of these problems (at least in a “good enough” sorta way) in my <a href="https://github.com/khalladay/hooking-by-example">hooking-by-example</a> repo, but others are left, I suppose, as an exercise for the reader. If you want to learn more, the sources for <a href="https://github.com/microsoft/Detours">Detours</a>, <a href="https://github.com/TsudaKageyu/minhook">Minhook</a>, <a href="https://easyhook.github.io/">Easyhook</a> and <a href="https://github.com/stevemk14ebr/PolyHook">Polyhook</a> might be of interest. I found the Polyhook code the easiest to read, for whatever that’s worth.</p>

<p>There’s also some really cool approaches to function hooking that don’t require you to know the function signature of what you’re hooking. I haven’t delved into this at all, but I’ve had <a href="https://github.com/vovkos/protolesshooks">this github repo</a> starred for awhile now.</p>

<p>Lastly, there’s a whole world of other hooking techniques out there. One that seems particularly interesting to me is import address table hooking, which <a href="https://renderdoc.org/">RenderDoc</a> uses. I expect I’ll lose several weekends to this very soon.</p>

<h2 id="final-thoughts">Final Thoughts</h2>
<p>I’ve written a lot already, so I’ll keep my sign off short. There are two things that I didn’t find room to mention in the ocean of text above that I think warrant a mention:</p>

<ol>
  <li>If you try to disassemble a function that you have breakpoints set in, you’re going to have a bad time.</li>
  <li>To debug an injected dll, attach your debugger to the process the dll was injected into.</li>
</ol>

<p>Finally, my twitter handle is <a href="https://twitter.com/khalladay">@khalladay</a>. Send me questions or comments or whatever there. I’ll probably respond, unless I’m tired that day and forget to come back to it later.</p>

</div>

<div id="related">
  <h3>Recent Posts</h3>
  <ul class="posts">
    
    <li>
      <span>14 Jul 2021 &raquo;</span> <a href="/blog/2021/07/14/Dll-Search-Order-Hijacking-For-PostProcess-Injection.html">Hooking and Hijacking DirectX 11 Functions In Skyrim</a>
    </li>
    
    <li>
      <span>13 Nov 2020 &raquo;</span> <a href="/blog/2020/11/13/Hooking-By-Example.html">X64 Function Hooking by Example</a>
    </li>
    
    <li>
      <span>20 May 2020 &raquo;</span> <a href="/blog/2020/05/20/Rendering-With-Notepad.html">Ray Tracing In Notepad.exe At 30 FPS</a>
    </li>
    
    <li>
      <span>20 May 2020 &raquo;</span> <a href="/blog/2020/05/20/Hooking-Input-Snake-In-Notepad.html">Hooking Keyboard Input To Play Snake In Notepad.exe</a>
    </li>
    
  </ul>
</div>


      <div class="footer">
        <div class="disclaimer">
  
  <p>
    The postings on this site are my own and don't necessarily represent my 
    employer’s positions, strategies or opinions.
  </p>
  

  <p>
    © Kyle Halladay, 2021 &mdash; built with <a href="http://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/swanson/lagom">Lagom theme</a>
  </p>
</div>
      </div>
    </div>
  </div>

</body>
</html>
